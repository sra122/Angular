"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ClassLikeExportDoc_1 = require("../api-doc-types/ClassLikeExportDoc");
function linkInheritedDocs(exportSymbolsToDocsMap, createDocMessage, log) {
    return new LinkInheritedDocs(exportSymbolsToDocsMap, createDocMessage, log);
}
exports.linkInheritedDocs = linkInheritedDocs;
var LinkInheritedDocs = /** @class */ (function () {
    function LinkInheritedDocs(exportSymbolsToDocsMap, createDocMessage, log) {
        this.exportSymbolsToDocsMap = exportSymbolsToDocsMap;
        this.createDocMessage = createDocMessage;
        this.log = log;
        this.$runAfter = ['readTypeScriptModules'];
        this.$runBefore = ['parsing-tags'];
    }
    LinkInheritedDocs.prototype.$process = function (docs) {
        var _this = this;
        docs.forEach(function (doc) {
            if (doc instanceof ClassLikeExportDoc_1.ClassLikeExportDoc) {
                _this.log.debug("- processing typecript doc " + doc.id + " for ancestors");
                doc.extendsClauses.forEach(function (clause) { return _this.updateHeritageInfo(doc, clause); });
                _this.log.debug('  - found "extends" ancestors: ' + doc.extendsClauses.map(function (clause) { return clause.doc && clause.doc.id; }).join(', '));
                _this.reportErrors(doc, doc.extendsClauses);
                doc.implementsClauses.forEach(function (clause) { return _this.updateHeritageInfo(doc, clause); });
                _this.log.debug('  - found "implements" ancestors: ' + doc.implementsClauses.map(function (clause) { return clause.doc && clause.doc.id; }).join(', '));
                _this.reportErrors(doc, doc.implementsClauses);
            }
        });
    };
    LinkInheritedDocs.prototype.updateHeritageInfo = function (doc, clause) {
        clause.symbol = doc.typeChecker.getTypeFromTypeNode(clause.type).getSymbol();
        clause.doc = clause.symbol && this.exportSymbolsToDocsMap.get(clause.symbol);
        if (clause.doc)
            clause.doc.descendants.push(doc);
    };
    LinkInheritedDocs.prototype.reportErrors = function (doc, clauses) {
        var missingSymbols = [];
        var missingDocs = [];
        clauses.forEach(function (clause) {
            if (!clause.doc) {
                (clause.symbol ? missingDocs : missingSymbols).push(clause.text);
            }
        });
        if (missingSymbols.length) {
            this.log.warn(this.createDocMessage("Unresolved TypeScript symbol(s): " + missingSymbols.join(', '), doc));
        }
        if (missingDocs.length) {
            this.createDocMessage("Missing API doc for the following symbol(s): " + missingDocs.join(', ') + ", (missing public export?)", doc);
        }
    };
    return LinkInheritedDocs;
}());
exports.LinkInheritedDocs = LinkInheritedDocs;
//# sourceMappingURL=linkInheritedDocs.js.map