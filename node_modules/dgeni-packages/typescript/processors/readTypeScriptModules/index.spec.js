"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var dgeni_1 = require("dgeni");
var mockPackage = require('../../mocks/mockPackage');
var path = require('canonical-path');
describe('readTypeScriptModules', function () {
    var dgeni;
    var injector;
    var processor;
    beforeEach(function () {
        dgeni = new dgeni_1.Dgeni([mockPackage()]);
        injector = dgeni.configureInjector();
        processor = injector.get('readTypeScriptModules');
        processor.basePath = path.resolve(__dirname, '../../mocks/readTypeScriptModules');
    });
    describe('exportDocs', function () {
        it('should extract all content from the comments', function () {
            processor.sourceFiles = ['commentContent.ts'];
            var docs = [];
            processor.$process(docs);
            var someClassDoc = docs.find(function (doc) { return doc.name === 'SomeClass'; });
            expect(someClassDoc.content).toEqual('@empty');
            var fooDoc = docs.find(function (doc) { return doc.name === 'foo'; });
            expect(fooDoc.content).toEqual('The description\n@tag1\ntag info');
            var barDoc = docs.find(function (doc) { return doc.name === 'bar'; });
            expect(barDoc.content).toEqual('@name bar\n@description\ndescription of bar {@inline-tag} more content');
        });
        it('should extract the starting and ending lines from the comments', function () {
            processor.sourceFiles = ['commentContent.ts'];
            var docs = [];
            processor.$process(docs);
            var someClassDoc = docs.find(function (doc) { return doc.name === 'SomeClass'; });
            expect(someClassDoc.startingLine).toEqual(0);
            expect(someClassDoc.endingLine).toEqual(17);
            var fooDoc = docs.find(function (doc) { return doc.name === 'foo'; });
            expect(fooDoc.startingLine).toEqual(4);
            expect(fooDoc.endingLine).toEqual(9);
            var barDoc = docs.find(function (doc) { return doc.name === 'bar'; });
            expect(barDoc.startingLine).toEqual(10);
            expect(barDoc.endingLine).toEqual(16);
        });
        it('should provide the original module if the export is re-exported', function () {
            processor.sourceFiles = ['publicModule.ts'];
            var docs = [];
            processor.$process(docs);
            var exportedDoc = docs[1];
            expect(exportedDoc.originalModule).toEqual('privateModule');
        });
        it('should include exported abstract classes', function () {
            processor.sourceFiles = ['publicModule.ts'];
            var docs = [];
            processor.$process(docs);
            var exportedDoc = docs[2];
            expect(exportedDoc.name).toEqual('AbstractClass');
        });
        it('should hide members marked as private in TypeScript', function () {
            processor.sourceFiles = ['privateMembers.ts'];
            var docs = [];
            processor.$process(docs);
            expect(docs.every(function (doc) { return doc.name !== 'privateProperty'; })).toBe(true);
        });
        it('should put static members into the `.statics` property of the export doc', function () {
            processor.sourceFiles = ['staticMembers.ts'];
            var docs = [];
            processor.$process(docs);
            var classDoc = docs.find(function (doc) { return doc.docType === 'class'; });
            expect(classDoc.statics.length).toEqual(2);
            expect(classDoc.statics.map(function (staticMember) { return staticMember.name; })).toEqual(['staticA', 'num']);
            expect(classDoc.members.length).toEqual(0);
        });
        it('should add additional declarations of a symbol onto the exportDoc', function () {
            processor.sourceFiles = ['multipleDeclarations.ts'];
            var docs = [];
            processor.$process(docs);
            var someThingDoc = docs.find(function (doc) { return doc.name === 'SomeThing'; });
            expect(someThingDoc.docType).toEqual('interface');
            expect(someThingDoc.content).toEqual('the constant doc');
            expect(someThingDoc.additionalDeclarations).toEqual([
                someThingDoc.symbol.getDeclarations()[0],
            ]);
        });
        it('should remove `index` from the end of module ids and names', function () {
            processor.sourceFiles = ['test/folder/index.ts'];
            var docs = [];
            processor.$process(docs);
            var moduleDoc = docs[0];
            expect(moduleDoc.id).toEqual('test/folder');
            expect(moduleDoc.name).toEqual('folder');
            var exportDoc = docs[1];
            expect(exportDoc.id).toEqual('test/folder/TestClass');
            expect(exportDoc.name).toEqual('TestClass');
        });
        it('should add each exportDoc to the exportSymbolsToDocsMap', function () {
            processor.sourceFiles = ['returnTypes.ts'];
            var docs = [];
            processor.$process(docs);
            var map = injector.get('exportSymbolsToDocsMap');
            expect(map.size).toEqual(2);
            map.forEach(function (doc, symbol) {
                expect(doc.symbol).toBe(symbol);
            });
        });
    });
    describe('ignoreExportsMatching', function () {
        it('should ignore exports that match items in the `ignoreExportsMatching` property', function () {
            processor.sourceFiles = ['ignoreExportsMatching.ts'];
            processor.ignoreExportsMatching = [/^_/];
            var docs = [];
            processor.$process(docs);
            var moduleDoc = docs[0];
            expect(moduleDoc.docType).toEqual('module');
            expect(moduleDoc.exports).toEqual([
                jasmine.objectContaining({ name: 'OKToExport' }),
                jasmine.objectContaining({ name: 'thisIsOK' }),
            ]);
        });
        it('should only ignore `__esModule` exports by default', function () {
            processor.sourceFiles = ['ignoreExportsMatching.ts'];
            var docs = [];
            processor.$process(docs);
            var moduleDoc = docs[0];
            expect(moduleDoc.docType).toEqual('module');
            expect(getNames(moduleDoc.exports)).toEqual([
                'OKToExport',
                '_thisIsPrivate',
                'thisIsOK',
            ]);
        });
    });
    describe('interfaces', function () {
        it('should mark optional properties', function () {
            processor.sourceFiles = ['interfaces.ts'];
            var docs = [];
            processor.$process(docs);
            var moduleDoc = docs[0];
            var exportedInterface = moduleDoc.exports[0];
            var member = exportedInterface.members[0];
            expect(member.name).toEqual('optionalProperty');
            expect(member.isOptional).toEqual(true);
        });
        it('should handle "call" type interfaces', function () {
            processor.sourceFiles = ['interfaces.ts'];
            var docs = [];
            processor.$process(docs);
            var moduleDoc = docs[0];
            var exportedInterface = moduleDoc.exports[0];
            var callMember = exportedInterface.members.find(function (member) { return member.isCallMember; });
            expect(callMember).toBeDefined();
            expect(callMember.parameters).toEqual(['param: T']);
            expect(callMember.type).toEqual('U');
            expect(callMember.typeParameters).toEqual('<T, U extends Findable<T>>');
            var newMember = exportedInterface.members.find(function (member) { return member.isNewMember; });
            expect(newMember).toBeDefined();
            expect(newMember.parameters).toEqual(['param: number']);
            expect(newMember.type).toEqual('MyInterface');
        });
    });
    describe('export aliases', function () {
        function getProcessedDocs() {
            var docs = [];
            processor.sourceFiles = ['exportAliases.ts'];
            processor.$process(docs);
            var _a = docs.filter(function (doc) { return doc.docType === 'class'; }), originalExport = _a[0], aliasedExport = _a[1];
            return { originalExport: originalExport, aliasedExport: aliasedExport };
        }
        it('should properly name the aliased export', function () {
            var _a = getProcessedDocs(), originalExport = _a.originalExport, aliasedExport = _a.aliasedExport;
            expect(originalExport.name).toEqual('OriginalExport');
            expect(originalExport.symbol.name).toEqual('OriginalExport');
            expect(aliasedExport.name).toEqual('AliasedExport');
            expect(aliasedExport.symbol.name).toEqual('OriginalExport');
        });
        it('should have the proper aliases resolved', function () {
            var _a = getProcessedDocs(), originalExport = _a.originalExport, aliasedExport = _a.aliasedExport;
            expect(originalExport.aliases).toEqual(['OriginalExport', 'exportAliases/OriginalExport']);
            expect(aliasedExport.aliases).toEqual(['AliasedExport', 'exportAliases/AliasedExport']);
        });
        it('should expose the alias symbol', function () {
            var _a = getProcessedDocs(), originalExport = _a.originalExport, aliasedExport = _a.aliasedExport;
            expect(originalExport.aliasSymbol).toBeUndefined();
            expect(aliasedExport.aliasSymbol).toBeDefined();
        });
        it('should expose the original symbols members', function () {
            var _a = getProcessedDocs(), originalExport = _a.originalExport, aliasedExport = _a.aliasedExport;
            expect(originalExport.members.map(function (memberDoc) { return memberDoc.id; })).toEqual(['exportAliases/OriginalExport.sayHello()']);
            expect(aliasedExport.members.map(function (memberDoc) { return memberDoc.id; })).toEqual(['exportAliases/AliasedExport.sayHello()']);
        });
    });
    describe('type aliases', function () {
        it('should find the correct type when there are multiple declarations', function () {
            processor.sourceFiles = ['type-aliases.ts'];
            var docs = [];
            processor.$process(docs);
            var typeAliasDoc = docs[2];
            expect(typeAliasDoc.docType).toEqual('type-alias');
            expect(typeAliasDoc.typeDefinition).toEqual('X<any>');
        });
        it('should include type parameters', function () {
            processor.sourceFiles = ['type-aliases.ts'];
            var docs = [];
            processor.$process(docs);
            var typeAliasDoc = docs.find(function (doc) { return doc.name === 'Parameterized'; });
            expect(typeAliasDoc.docType).toEqual('type-alias');
            expect(typeAliasDoc.typeParameters).toEqual('<T, R>');
        });
    });
    describe('exported functions', function () {
        it('should include type parameters', function () {
            processor.sourceFiles = ['functions.ts'];
            var docs = [];
            processor.$process(docs);
            var functionDoc = docs.find(function (doc) { return doc.name === 'foo'; });
            expect(functionDoc.docType).toEqual('function');
            expect(functionDoc.typeParameters).toEqual('<T, R>');
        });
    });
    describe('exported consts', function () {
        it('should extract a text form of the type of the constant', function () {
            processor.sourceFiles = ['consts.ts'];
            var docs = [];
            processor.$process(docs);
            var constDocs = docs.filter(function (doc) { return doc.docType === 'const'; });
            expect(constDocs[0].name).toEqual('X');
            expect(constDocs[0].type).toEqual('"x"');
            expect(constDocs[1].name).toEqual('fun');
            expect(constDocs[1].type).toEqual('(foo: string) => boolean');
            expect(constDocs[2].name).toEqual('OBJ');
            expect(constDocs[2].type).toEqual('{ prop1: boolean; prop2: string; }');
            expect(constDocs[3].name).toEqual('INSTANCE');
            expect(constDocs[3].type).toEqual('CLASS<string>');
        });
    });
    describe('members', function () {
        describe('overloaded members', function () {
            it('should create a member doc for the "real" member, which includes an overloads property', function () {
                processor.sourceFiles = ['overloadedMembers.ts'];
                var docs = [];
                processor.$process(docs);
                var foo = docs.find(function (doc) { return doc.name === 'foo'; });
                expect(foo.parameters).toEqual(['num1: string | number', 'num2?: number']);
                var overloads = foo.overloads;
                expect(overloads.map(function (overload) { return overload.parameters; })).toEqual([
                    ['str: string'],
                    ['num1: number', 'num2: number'],
                ]);
            });
            it('should use the first declaration as the member doc if no overload has a body', function () {
                processor.sourceFiles = ['overloadedMembers.ts'];
                var docs = [];
                processor.$process(docs);
                var bar = docs.find(function (doc) { return doc.name === 'bar'; });
                expect(bar.overloads.length).toEqual(1);
                expect(bar.parameters).toEqual(['str: string']);
                expect(bar.overloads[0].parameters).toEqual([]);
            });
        });
        describe('overloaded constructors', function () {
            it('should create a member doc for the "real" constructor, which includes an overloads property', function () {
                processor.sourceFiles = ['overloadedMembers.ts'];
                var docs = [];
                processor.$process(docs);
                var foo = docs.find(function (doc) { return doc.name === 'constructor'; });
                expect(foo.parameters).toEqual(['x: string', 'y: string | number', 'z?: number']);
                var overloads = foo.overloads;
                expect(overloads.map(function (overload) { return overload.parameters; })).toEqual([
                    ['x: string', 'y: number'],
                    ['x: string', 'y: string', 'z: number'],
                ]);
            });
        });
        describe('ordering of members', function () {
            it('should order class members in order of appearance (by default)', function () {
                processor.sourceFiles = ['orderingOfMembers.ts'];
                var docs = [];
                processor.$process(docs);
                var classDoc = docs.find(function (doc) { return doc.docType === 'class'; });
                expect(classDoc.docType).toEqual('class');
                expect(getNames(classDoc.members)).toEqual([
                    'firstItem',
                    'otherMethod',
                    'doStuff',
                ]);
            });
            it('should not order class members if not sortClassMembers is false', function () {
                processor.sourceFiles = ['orderingOfMembers.ts'];
                processor.sortClassMembers = false;
                var docs = [];
                processor.$process(docs);
                var classDoc = docs.find(function (doc) { return doc.docType === 'class'; });
                expect(classDoc.docType).toEqual('class');
                expect(getNames(classDoc.members)).toEqual([
                    'firstItem',
                    'otherMethod',
                    'doStuff',
                ]);
            });
        });
        describe('return types', function () {
            it('should not throw if "declaration.initializer.expression.text" is undefined', function () {
                processor.sourceFiles = ['returnTypes.ts'];
                var docs = [];
                expect(function () { processor.$process(docs); }).not.toThrow();
            });
            it('should return the text of the type if initialized', function () {
                processor.sourceFiles = ['returnTypes.ts'];
                var docs = [];
                processor.$process(docs);
                var propDocs = docs.filter(function (doc) { return doc.name === 'someProp'; });
                expect(propDocs[0].type).toEqual([
                    '{',
                    '    foo: \'bar\'',
                    '}',
                ].join('\n'));
                expect(propDocs[1].type).toEqual([
                    'Object.assign(this.someProp, {',
                    '    bar: \'baz\'',
                    '})',
                ].join('\n'));
            });
        });
        describe('member modifiers', function () {
            it('should set the readOnly flag on readonly members', function () {
                processor.sourceFiles = ['memberModifiers.ts'];
                var docs = [];
                processor.$process(docs);
                var simpleProp = docs.filter(function (doc) { return doc.name === 'foo'; })[0];
                expect(simpleProp.isReadonly).toBeFalsy();
                var readonlyProp = docs.filter(function (doc) { return doc.name === 'bar'; })[0];
                expect(readonlyProp.isReadonly).toBeTruthy();
            });
        });
        describe('getters and setters', function () {
            var docs;
            var foo1;
            var foo1Getter;
            var foo1Setter;
            var foo2;
            var foo2Getter;
            var foo2Setter;
            var bar;
            var barGetter;
            var barSetter;
            var qux;
            var quxGetter;
            var quxSetter;
            var noType;
            var noTypeGetter;
            var noTypeSetter;
            var decoratorProp;
            var decoratorPropGetter;
            var decoratorPropSetter;
            beforeEach(function () {
                processor.sourceFiles = ['gettersAndSetters.ts'];
                docs = [];
                processor.$process(docs);
                foo1 = docs.find(function (doc) { return doc.name === 'foo1'; });
                foo2 = docs.find(function (doc) { return doc.name === 'foo2'; });
                bar = docs.find(function (doc) { return doc.name === 'bar'; });
                qux = docs.find(function (doc) { return doc.name === 'qux'; });
                noType = docs.find(function (doc) { return doc.name === 'noType'; });
                decoratorProp = docs.find(function (doc) { return doc.name === 'decoratorProp'; });
                foo1Getter = docs.find(function (doc) { return doc.name === 'foo1:get'; });
                foo1Setter = docs.find(function (doc) { return doc.name === 'foo1:set'; });
                foo2Getter = docs.find(function (doc) { return doc.name === 'foo2:get'; });
                foo2Setter = docs.find(function (doc) { return doc.name === 'foo2:set'; });
                barGetter = docs.find(function (doc) { return doc.name === 'bar:get'; });
                barSetter = docs.find(function (doc) { return doc.name === 'bar:set'; });
                quxGetter = docs.find(function (doc) { return doc.name === 'qux:get'; });
                quxSetter = docs.find(function (doc) { return doc.name === 'qux:set'; });
                noTypeGetter = docs.find(function (doc) { return doc.name === 'noType:get'; });
                noTypeSetter = docs.find(function (doc) { return doc.name === 'noType:set'; });
                decoratorPropGetter = docs.find(function (doc) { return doc.name === 'decoratorProp:get'; });
                decoratorPropSetter = docs.find(function (doc) { return doc.name === 'decoratorProp:set'; });
            });
            it('should create a property member doc for property that has accessors', function () {
                expect(foo1).toBeDefined();
                expect(foo1.docType).toBe('member');
                expect(foo2).toBeDefined();
                expect(foo2.docType).toBe('member');
                expect(bar).toBeDefined();
                expect(bar.docType).toBe('member');
                expect(qux).toBeDefined();
                expect(qux.docType).toBe('member');
            });
            it('should create a doc for each accessor of a property', function () {
                expect(foo1Getter).toBeDefined();
                expect(foo1Getter.docType).toBe('get-accessor-info');
                expect(foo1Getter.content).toEqual('');
                expect(foo1Setter).toBeDefined();
                expect(foo1Setter.docType).toBe('set-accessor-info');
                expect(foo1Setter.content).toEqual('foo1 setter');
                expect(foo2Getter).toBeDefined();
                expect(foo2Getter.docType).toBe('get-accessor-info');
                expect(foo2Getter.content).toEqual('foo2 getter');
                expect(foo2Setter).toBeDefined();
                expect(foo2Setter.docType).toBe('set-accessor-info');
                expect(foo2Setter.content).toEqual('');
                expect(barGetter).toBeDefined();
                expect(barGetter.docType).toBe('get-accessor-info');
                expect(barGetter.content).toEqual('bar getter');
                expect(barSetter).toBeUndefined();
                expect(quxGetter).toBeUndefined();
                expect(quxSetter).toBeDefined();
                expect(quxSetter.docType).toBe('set-accessor-info');
                expect(quxSetter.content).toEqual('qux setter');
            });
            it('should compute the type of the property from its accessors', function () {
                expect(foo1.type).toEqual('string');
                expect(foo2.type).toEqual('string');
                expect(bar.type).toEqual('number');
                expect(qux.type).toEqual('object');
                expect(noType.type).toEqual('string');
            });
            it('should compute the content of the property from its accessors', function () {
                expect(foo1.content).toEqual('foo1 setter');
                expect(foo2.content).toEqual('foo2 getter');
                expect(bar.content).toEqual('bar getter');
                expect(qux.content).toEqual('qux setter');
                expect(noType.content).toEqual('This has no explicit getter return type');
            });
            it('should attach each accessor doc to its property doc', function () {
                expect(foo1.getAccessor).toBe(foo1Getter);
                expect(foo1.setAccessor).toBe(foo1Setter);
                expect(foo2.getAccessor).toBe(foo2Getter);
                expect(foo2.setAccessor).toBe(foo2Setter);
                expect(bar.getAccessor).toBe(barGetter);
                expect(bar.setAccessor).toBe(null);
                expect(qux.getAccessor).toBe(null);
                expect(qux.setAccessor).toBe(quxSetter);
            });
            describe('if getter is missing information', function () {
                it('should add decorators of the setter to the property doc', function () {
                    expect(decoratorProp.decorators[0].name).toBe('SomeDecorator');
                });
                it('should add description of the setter to the property doc', function () {
                    expect(decoratorProp.content).toBe('Description of myProperty.');
                });
                it('should add type of the setter to the property doc', function () {
                    expect(decoratorProp.type).toBe('string');
                });
            });
        });
        describe('method parameters', function () {
            it('should process method parameters', function () {
                processor.sourceFiles = ['methodParameters.ts'];
                var docs = [];
                processor.$process(docs);
                var param1 = docs.find(function (doc) { return doc.name === 'param1' && doc.container.name === 'method1'; });
                expect(param1.docType).toEqual('parameter');
                expect(param1.id).toEqual('methodParameters/TestClass.method1()~param1');
                expect(param1.content).toEqual('description of param1');
                expect(param1.type).toEqual('number');
                expect(param1.isOptional).toBe(false);
                expect(param1.defaultValue).toBeUndefined();
                var param2 = docs.find(function (doc) { return doc.name === 'param2' && doc.container.name === 'method1'; });
                expect(param2.docType).toEqual('parameter');
                expect(param2.id).toEqual('methodParameters/TestClass.method1()~param2');
                expect(param2.content).toEqual('description of param2');
                expect(param2.type).toEqual('string');
                expect(param2.isOptional).toBe(true);
                expect(param2.defaultValue).toBeUndefined();
                var param3 = docs.find(function (doc) { return doc.name === 'param3' && doc.container.name === 'method1'; });
                expect(param3.docType).toEqual('parameter');
                expect(param3.id).toEqual('methodParameters/TestClass.method1()~param3');
                expect(param3.content).toEqual('description of param3');
                expect(param3.type).toEqual('object');
                expect(param3.isOptional).toBe(false);
                expect(param3.defaultValue).toBe('{}');
                var param4 = docs.find(function (doc) { return doc.name === 'param4' && doc.container.name === 'method1'; });
                expect(param4.docType).toEqual('parameter');
                expect(param4.id).toEqual('methodParameters/TestClass.method1()~param4');
                expect(param4.content).toEqual('description of param4');
                expect(param4.type).toEqual('string');
                expect(param4.isOptional).toBe(false);
                expect(param4.defaultValue).toBe('\'default string\'');
                var method1 = docs.find(function (doc) { return doc.name === 'method1'; });
                expect(method1.parameterDocs).toEqual([param1, param2, param3, param4]);
            });
        });
        describe('aliases', function () {
            var docs;
            var fn;
            var foo;
            var foo1;
            var foo2;
            var bar;
            beforeEach(function () {
                processor.sourceFiles = ['memberAliases.ts'];
                docs = [];
                processor.$process(docs);
                fn = docs.find(function (doc) { return doc.name === 'fn'; });
                _a = docs.filter(function (doc) { return doc.name === 'foo'; }), foo2 = _a[0], foo = _a[1], foo1 = _a[2];
                bar = docs.find(function (doc) { return doc.name === 'bar'; });
                var _a;
            });
            it('should include a simple name', function () {
                expect(fn.aliases).toContain('fn()');
                expect(foo.aliases).toContain('foo()');
                expect(bar.aliases).toContain('bar');
            });
            it('should include the container', function () {
                expect(fn.aliases).toContain('MyClass.fn()');
                expect(foo.aliases).toContain('MyClass.foo()');
                expect(bar.aliases).toContain('MyClass.bar');
            });
            it('should include the container and module', function () {
                expect(fn.aliases).toContain('memberAliases/MyClass.fn()');
                expect(foo.aliases).toContain('memberAliases/MyClass.foo()');
                expect(bar.aliases).toContain('memberAliases/MyClass.bar');
            });
            it('should distinguish method overloads', function () {
                expect(foo.aliases).toContain('MyClass.foo()');
                expect(foo1.aliases).toContain('MyClass.foo_1()');
                expect(foo2.aliases).toContain('MyClass.foo_2()');
            });
        });
    });
    describe('namespaces', function () {
        it('should not strip namespaces in return types', function () {
            processor.sourceFiles = ['stripNamespaces.ts'];
            var docs = [];
            processor.$process(docs);
            var functionDoc = docs.find(function (doc) { return doc.docType === 'function'; });
            expect(functionDoc.type).toEqual('angular.IDirective');
        });
        it('should cope with spread operator', function () {
            processor.sourceFiles = ['spreadParams.ts'];
            var docs = [];
            processor.$process(docs);
            var functionDoc = docs.find(function (doc) { return doc.docType === 'function'; });
            expect(functionDoc.parameters).toEqual(['...args: any[]']);
            expect(functionDoc.type).toEqual('void');
            var interfaceDoc = docs.find(function (doc) { return doc.docType === 'interface'; });
            expect(interfaceDoc.members.length).toEqual(2);
            var methodDoc = interfaceDoc.members[0];
            expect(methodDoc.parameters).toEqual(['...args: any[]']);
            expect(methodDoc.type).toEqual('void');
            var propertyDoc = interfaceDoc.members[1];
            expect(propertyDoc.type).toEqual('(...args: Array<any>) => void');
        });
    });
    describe('source file globbing patterns', function () {
        it('should work with include patterns', function () {
            processor.sourceFiles = [
                {
                    include: '*Module.ts',
                },
            ];
            var docs = [];
            processor.$process(docs);
            var moduleDocs = docs.filter(function (doc) { return doc.docType === 'module'; });
            expect(moduleDocs.length).toBe(2);
            expect(moduleDocs[0].name).toEqual('privateModule');
            expect(moduleDocs[1].name).toEqual('publicModule');
        });
        it('should work with include/exclude patterns', function () {
            processor.sourceFiles = [
                {
                    exclude: 'public*.ts',
                    include: '*Module.ts',
                },
            ];
            var docs = [];
            processor.$process(docs);
            var moduleDoc = docs[0];
            expect(moduleDoc.name).toEqual('privateModule');
        });
    });
});
function getNames(collection) {
    return collection.map(function (item) { return item.name; });
}
//# sourceMappingURL=index.spec.js.map