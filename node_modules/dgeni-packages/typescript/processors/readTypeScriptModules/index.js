"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ClassExportDoc_1 = require("../../api-doc-types/ClassExportDoc");
var ConstExportDoc_1 = require("../../api-doc-types/ConstExportDoc");
var EnumExportDoc_1 = require("../../api-doc-types/EnumExportDoc");
var FunctionExportDoc_1 = require("../../api-doc-types/FunctionExportDoc");
var InterfaceExportDoc_1 = require("../../api-doc-types/InterfaceExportDoc");
var MethodMemberDoc_1 = require("../../api-doc-types/MethodMemberDoc");
var ModuleDoc_1 = require("../../api-doc-types/ModuleDoc");
var PropertyMemberDoc_1 = require("../../api-doc-types/PropertyMemberDoc");
var TypeAliasExportDoc_1 = require("../../api-doc-types/TypeAliasExportDoc");
var TsParser_1 = require("../../services/TsParser");
var SourcePattern_1 = require("./SourcePattern");
// This import lacks type definitions.
var path = require('canonical-path');
function readTypeScriptModules(tsParser, tsHost, modules, exportSymbolsToDocsMap, createDocMessage, log) {
    return new ReadTypeScriptModules(tsParser, tsHost, modules, exportSymbolsToDocsMap, createDocMessage, log);
}
exports.readTypeScriptModules = readTypeScriptModules;
var ReadTypeScriptModules = /** @class */ (function () {
    function ReadTypeScriptModules(tsParser, host, modules, exportSymbolsToDocsMap, createDocMessage, log) {
        this.tsParser = tsParser;
        this.host = host;
        this.modules = modules;
        this.exportSymbolsToDocsMap = exportSymbolsToDocsMap;
        this.createDocMessage = createDocMessage;
        this.log = log;
        this.$runAfter = ['files-read'];
        this.$runBefore = ['parsing-tags'];
        this.$validate = {
            basePath: { presence: true },
            hidePrivateMembers: { inclusion: [true, false] },
            ignoreExportsMatching: {},
            sortClassMembers: { inclusion: [true, false] },
            sourceFiles: { presence: true },
        };
        // A collection of globs that identify those modules for which we should create docs
        this.sourceFiles = [];
        // The base path from which to load the source files
        this.basePath = '.';
        // We can ignore members of classes that are private
        this.hidePrivateMembers = true;
        // We leave class members sorted in order of declaration
        this.sortClassMembers = false;
        // We can provide a collection of strings or regexes to ignore exports whose export names match
        this.ignoreExportsMatching = ['__esModule'];
        this.ignoreExportsRegexes = [];
    }
    ReadTypeScriptModules.prototype.$process = function (docs) {
        // Convert ignoreExportsMatching to an array of regexes
        this.ignoreExportsRegexes = convertToRegexCollection(this.ignoreExportsMatching);
        // Extract the modules from source files via the TypeScript parser
        var basePath = path.resolve(this.basePath);
        var filesPaths = SourcePattern_1.expandSourceFiles(this.sourceFiles, basePath);
        var parseInfo = this.tsParser.parse(filesPaths, this.basePath);
        this.addModuleDocs(docs, parseInfo.moduleSymbols, basePath);
    };
    ReadTypeScriptModules.prototype.addModuleDocs = function (docs, moduleSymbols, basePath) {
        var _this = this;
        // Iterate through each of the modules to generate module docs, export docs and member docs.
        moduleSymbols.forEach(function (moduleSymbol) {
            // Create a doc for this module and add it to the module lookup collection and the docs collection
            var moduleDoc = new ModuleDoc_1.ModuleDoc(moduleSymbol, basePath, _this.hidePrivateMembers, moduleSymbols.typeChecker);
            _this.modules[moduleDoc.id] = moduleDoc;
            docs.push(moduleDoc);
            _this.addExportDocs(docs, moduleDoc);
        });
    };
    ReadTypeScriptModules.prototype.addExportDocs = function (docs, moduleDoc) {
        var _this = this;
        // Iterate through this module's exports and generate a doc for each
        moduleDoc.symbol.exportArray.forEach(function (exportSymbol) {
            // Ignore exports that match the configured regular expressions
            if (anyMatches(_this.ignoreExportsRegexes, exportSymbol.name))
                return;
            // If `exportSymbol.resolvedSymbol` is defined then the symbol has been "aliased":
            // * `exportSymbol.resolvedSymbol` holds the actual info about the symbol being exported
            // * `exportSymbol` is the "alias" symbol, which has the new name for the symbol being exported
            var resolvedExport = exportSymbol.resolvedSymbol || exportSymbol;
            var aliasSymbol = exportSymbol.resolvedSymbol ? exportSymbol : undefined;
            // If the resolved symbol contains no declarations then it is invalid (perhaps an abstract class?)
            // For the moment we are just going to ignore such exports (:scream:)
            // TODO: find a way of generating docs for them
            if (!resolvedExport.declarations) {
                _this.log.info("Export has no declarations: " + resolvedExport.name);
                return;
            }
            switch (TsParser_1.getExportDocType(resolvedExport)) {
                case 'class':
                    var classDoc = new ClassExportDoc_1.ClassExportDoc(_this.host, moduleDoc, resolvedExport, aliasSymbol);
                    _this.addMemberDocs(docs, classDoc.members);
                    _this.addMemberDocs(docs, classDoc.statics);
                    if (classDoc.constructorDoc)
                        _this.addMemberDocs(docs, [classDoc.constructorDoc]);
                    _this.addExportDoc(docs, moduleDoc, classDoc);
                    break;
                case 'interface':
                    var interfaceDoc = new InterfaceExportDoc_1.InterfaceExportDoc(_this.host, moduleDoc, resolvedExport, aliasSymbol);
                    _this.addMemberDocs(docs, interfaceDoc.members);
                    _this.addExportDoc(docs, moduleDoc, interfaceDoc);
                    break;
                case 'enum':
                    var enumDoc = new EnumExportDoc_1.EnumExportDoc(_this.host, moduleDoc, resolvedExport, aliasSymbol);
                    enumDoc.members.forEach(function (doc) { return docs.push(doc); });
                    _this.addExportDoc(docs, moduleDoc, enumDoc);
                    break;
                case 'const':
                case 'let':
                case 'var':
                    _this.addExportDoc(docs, moduleDoc, new ConstExportDoc_1.ConstExportDoc(_this.host, moduleDoc, resolvedExport, aliasSymbol));
                    break;
                case 'type-alias':
                    _this.addExportDoc(docs, moduleDoc, new TypeAliasExportDoc_1.TypeAliasExportDoc(_this.host, moduleDoc, resolvedExport, aliasSymbol));
                    break;
                case 'function':
                    var functionDoc = new FunctionExportDoc_1.FunctionExportDoc(_this.host, moduleDoc, resolvedExport, aliasSymbol);
                    _this.addExportDoc(docs, moduleDoc, functionDoc);
                    _this.addParamDocs(docs, functionDoc.parameterDocs);
                    functionDoc.overloads.forEach(function (overloadDoc) {
                        docs.push(overloadDoc);
                        _this.addParamDocs(docs, overloadDoc.parameterDocs);
                    });
                    break;
                default:
                    _this.log.error("Don't know how to create export document for " + resolvedExport.name);
                    break;
            }
        });
    };
    ReadTypeScriptModules.prototype.addExportDoc = function (docs, moduleDoc, exportDoc) {
        this.log.debug('>>>> EXPORT: ' + exportDoc.name + ' (' + exportDoc.docType + ') from ' + moduleDoc.id);
        moduleDoc.exports.push(exportDoc);
        docs.push(exportDoc);
        this.exportSymbolsToDocsMap.set(exportDoc.symbol, exportDoc);
    };
    ReadTypeScriptModules.prototype.addMemberDocs = function (docs, members) {
        var _this = this;
        members.forEach(function (member) {
            docs.push(member);
            if (member instanceof MethodMemberDoc_1.MethodMemberDoc) {
                _this.addParamDocs(docs, member.parameterDocs);
                member.overloads.forEach(function (overloadDoc) {
                    docs.push(overloadDoc);
                    _this.addParamDocs(docs, overloadDoc.parameterDocs);
                });
            }
            if (member instanceof PropertyMemberDoc_1.PropertyMemberDoc) {
                if (member.getAccessor)
                    docs.push(member.getAccessor);
                if (member.setAccessor) {
                    docs.push(member.setAccessor);
                    _this.addParamDocs(docs, member.setAccessor.parameterDocs);
                }
            }
        });
    };
    ReadTypeScriptModules.prototype.addParamDocs = function (docs, parameters) {
        parameters.forEach(function (parameter) { return docs.push(parameter); });
    };
    return ReadTypeScriptModules;
}());
exports.ReadTypeScriptModules = ReadTypeScriptModules;
function convertToRegexCollection(items) {
    if (!items)
        return [];
    // Must be an array
    if (!Array.isArray(items))
        items = [items];
    // Convert string to exact matching regexes
    return items.map(function (item) { return item instanceof RegExp ? item : new RegExp('^' + item + '$'); });
}
function anyMatches(regexes, item) {
    for (var _i = 0, regexes_1 = regexes; _i < regexes_1.length; _i++) {
        var regex = regexes_1[_i];
        if (item.match(regex)) {
            return true;
        }
    }
    return false;
}
//# sourceMappingURL=index.js.map