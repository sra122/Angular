"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable:no-bitwise */
var typescript_1 = require("typescript");
var getAccessibility_1 = require("../services/TsParser/getAccessibility");
var ExportDoc_1 = require("./ExportDoc");
var MethodMemberDoc_1 = require("./MethodMemberDoc");
var PropertyMemberDoc_1 = require("./PropertyMemberDoc");
var MethodMemberFlags = typescript_1.SymbolFlags.Method |
    typescript_1.SymbolFlags.Signature |
    typescript_1.SymbolFlags.Constructor |
    typescript_1.SymbolFlags.Accessor;
var PropertyMemberFlags = typescript_1.SymbolFlags.Property | typescript_1.SymbolFlags.EnumMember;
var MembersToIgnoreFlags = typescript_1.SymbolFlags.Prototype | typescript_1.SymbolFlags.TypeParameter | typescript_1.SymbolFlags.Constructor;
/**
 * This document represents things that contain members such as classes, enums and interfaces.
 *
 * Although such things can have multiple mergeable declarations, we consider them as a single doc.
 * So such documents are not OverloadableExport docs.
 */
var ContainerExportDoc = /** @class */ (function (_super) {
    __extends(ContainerExportDoc, _super);
    function ContainerExportDoc() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.members = [];
        return _this;
    }
    ContainerExportDoc.prototype.getMemberDocs = function (members, hidePrivateMembers) {
        var _this = this;
        var memberDocs = [];
        members.forEach(function (member) {
            var flags = member.getFlags();
            // Ignore the prototype export
            if (flags & MembersToIgnoreFlags)
                return;
            // Ignore private members, if configured to do so
            if (hidePrivateMembers && getAccessibility_1.getAccessibility(member.valueDeclaration) === 'private')
                return;
            var overloads = [];
            var memberDoc = null;
            var getAccessorDeclaration = null;
            var setAccessorDeclaration = null;
            for (var _i = 0, _a = member.getDeclarations(); _i < _a.length; _i++) {
                var declaration = _a[_i];
                if (flags & MethodMemberFlags) {
                    if (declaration.kind === typescript_1.SyntaxKind.GetAccessor) {
                        getAccessorDeclaration = declaration;
                    }
                    else if (declaration.kind === typescript_1.SyntaxKind.SetAccessor) {
                        setAccessorDeclaration = declaration;
                    }
                    else if (declaration.body) {
                        // This is the "real" declaration of the method
                        memberDoc = new MethodMemberDoc_1.MethodMemberDoc(_this.host, _this, member, declaration, overloads);
                    }
                    else {
                        // This is an overload signature of the method
                        overloads.push(new MethodMemberDoc_1.MethodMemberDoc(_this.host, _this, member, declaration, overloads));
                    }
                }
                else if (flags & PropertyMemberFlags) {
                    memberDoc = new PropertyMemberDoc_1.PropertyMemberDoc(_this.host, _this, member, declaration, null, null);
                }
                else {
                    throw new Error("Unknown member type for member " + member.name);
                }
            }
            // If at least one of the declarations was an accessor then the whole member is a property.
            if (getAccessorDeclaration || setAccessorDeclaration) {
                memberDoc = new PropertyMemberDoc_1.PropertyMemberDoc(_this.host, _this, member, null, getAccessorDeclaration, setAccessorDeclaration);
            }
            // If there is no member doc then we are in an interface or abstract class and we just take the first overload
            // as the primary one.
            memberDocs.push(memberDoc || overloads.shift());
        });
        return memberDocs;
    };
    return ContainerExportDoc;
}(ExportDoc_1.ExportDoc));
exports.ContainerExportDoc = ContainerExportDoc;
//# sourceMappingURL=ContainerExportDoc.js.map