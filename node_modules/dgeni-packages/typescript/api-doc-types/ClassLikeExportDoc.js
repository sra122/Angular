"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable:no-bitwise */
/* tslint:disable:max-classes-per-file */
var typescript_1 = require("typescript");
var getDecorators_1 = require("../services/TsParser/getDecorators");
var getTypeText_1 = require("../services/TsParser/getTypeText");
var ContainerExportDoc_1 = require("./ContainerExportDoc");
var HeritageInfo = /** @class */ (function () {
    function HeritageInfo(type, text) {
        this.type = type;
        this.text = text;
    }
    return HeritageInfo;
}());
exports.HeritageInfo = HeritageInfo;
/**
 * Interfaces and classes are "class-like", in that they can contain members, heritage, type parameters and decorators
 */
var ClassLikeExportDoc = /** @class */ (function (_super) {
    __extends(ClassLikeExportDoc, _super);
    function ClassLikeExportDoc(host, moduleDoc, symbol, declaration, aliasSymbol) {
        var _this = _super.call(this, host, moduleDoc, symbol, declaration, aliasSymbol) || this;
        _this.decorators = getDecorators_1.getDecorators(_this.declaration);
        _this.extendsClauses = [];
        _this.implementsClauses = [];
        _this.descendants = [];
        _this.typeParams = _this.computeTypeParams();
        _this.computeHeritageClauses();
        _this.addAliases();
        return _this;
    }
    ClassLikeExportDoc.prototype.computeTypeParams = function () {
        if (this.symbol.members) {
            var typeParams_1 = [];
            this.symbol.members.forEach(function (member) {
                if (member.getFlags() & typescript_1.SymbolFlags.TypeParameter) {
                    typeParams_1.push(typescript_1.symbolName(member));
                }
            });
            if (typeParams_1.length)
                return "<" + typeParams_1.join(', ') + ">";
        }
        return '';
    };
    ClassLikeExportDoc.prototype.addAliases = function () {
        if (this.typeParams) {
            // Make sure duplicate aliases aren't created, so "Ambiguous link" warnings are prevented
            this.aliases.push(this.name + this.typeParams);
            this.aliases.push(this.moduleDoc.id + '/' + this.name + this.typeParams);
        }
    };
    ClassLikeExportDoc.prototype.computeHeritageClauses = function () {
        var _this = this;
        // Collect up all the heritage clauses from each declaration
        // (interfaces can have multiple declarations, which are merged, each with their own heritage)
        this.symbol.getDeclarations().forEach(function (declaration) {
            getHeritage(declaration).forEach(function (clause) {
                // Now process these clauses to find each "extends" and "implements" clause
                if (clause.token === typescript_1.SyntaxKind.ExtendsKeyword) {
                    _this.extendsClauses = _this.extendsClauses.concat(clause.types.map(function (heritageType) { return new HeritageInfo(heritageType, getTypeText_1.getTypeText(heritageType)); }));
                }
                else {
                    _this.implementsClauses = _this.implementsClauses.concat(clause.types.map(function (heritageType) { return new HeritageInfo(heritageType, getTypeText_1.getTypeText(heritageType)); }));
                }
            });
        });
    };
    return ClassLikeExportDoc;
}(ContainerExportDoc_1.ContainerExportDoc));
exports.ClassLikeExportDoc = ClassLikeExportDoc;
function getHeritage(declaration) {
    return declaration.heritageClauses || [];
}
//# sourceMappingURL=ClassLikeExportDoc.js.map