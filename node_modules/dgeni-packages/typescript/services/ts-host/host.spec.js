"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var dgeni_1 = require("dgeni");
var typescript_1 = require("typescript");
var mockPackage = require('../../mocks/mockPackage');
var path = require('canonical-path');
describe('Host', function () {
    var basePath = path.resolve(__dirname, '../../mocks/tsParser');
    var host;
    var parser;
    /**
     * Creates the Host instance through Dgeni dependency injection. Also allows passing a function
     * that will run in Dgeni's configuration lifecycle and allows modifying the host factory.
     */
    function setupTestDgeniInstance(configureFn) {
        var testPackage = mockPackage();
        if (configureFn) {
            testPackage.config(function (tsHost) { return configureFn(tsHost); });
        }
        var dgeni = new dgeni_1.Dgeni([testPackage]);
        var injector = dgeni.configureInjector();
        // Load factories from the Dgeni injector.
        host = injector.get('tsHost');
        parser = injector.get('tsParser');
    }
    it("should read content of a declaration", function () {
        setupTestDgeniInstance(function (h) { return h.concatMultipleLeadingComments = true; });
        var parseInfo = parser.parse(['multipleLeadingComments.ts'], basePath);
        var module = parseInfo.moduleSymbols[0];
        var declaration = module.exportArray[0].valueDeclaration;
        expect(host.getContent(declaration))
            .toEqual('Not a license comment.\nThis is a test function');
    });
    it('should be able to disable leading comment concatenation', function () {
        setupTestDgeniInstance(function (h) { return h.concatMultipleLeadingComments = false; });
        var parseInfo = parser.parse(['multipleLeadingComments.ts'], basePath);
        var module = parseInfo.moduleSymbols[0];
        var declaration = module.exportArray[0].valueDeclaration;
        expect(host.getContent(declaration)).toEqual('This is a test function');
    });
    describe('type to string conversion', function () {
        it('should properly determine type strings', function () {
            setupTestDgeniInstance();
            var _a = parser.parse(['typeToString.ts'], basePath), moduleSymbols = _a.moduleSymbols, typeChecker = _a.typeChecker;
            var testDeclarations = moduleSymbols[0].exportArray
                .map(function (symbol) { return symbol.valueDeclaration; });
            var typeStrings = [
                typeChecker.getTypeAtLocation(testDeclarations[0].initializer),
                typeChecker.getTypeFromTypeNode(testDeclarations[1].type),
                typeChecker.getTypeAtLocation(testDeclarations[2].initializer),
            ].map(function (type) { return host.typeToString(typeChecker, type); });
            expect(typeStrings[0]).toBe('"someString"');
            expect(typeStrings[1]).toBe('number');
            expect(typeStrings[2]).toBe('{ A: string; B: string; C: string; D: string; E: string; F: string; G: string; H: string; I: stri...');
        });
        it('should be able to specify type format flags', function () {
            setupTestDgeniInstance(function (h) { return h.typeFormatFlags = typescript_1.TypeFormatFlags.NoTruncation; });
            var _a = parser.parse(['typeToString.ts'], basePath), moduleSymbols = _a.moduleSymbols, typeChecker = _a.typeChecker;
            var typeDeclaration = moduleSymbols[0].exportArray[2]
                .valueDeclaration;
            var longType = typeChecker.getTypeAtLocation(typeDeclaration.initializer);
            expect(host.typeToString(typeChecker, longType)).toBe('{ A: string; B: string; C: string; D: string; E: string; F: string; G: string; H: string; I: string; J: string; K: string; L: string; M: string; N: string; }');
        });
    });
});
//# sourceMappingURL=host.spec.js.map