"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var typescript_1 = require("typescript");
var ClassExportDoc_1 = require("../api-doc-types/ClassExportDoc");
var ClassLikeExportDoc_1 = require("../api-doc-types/ClassLikeExportDoc");
var convertPrivateClassesToInterfaces_1 = require("./convertPrivateClassesToInterfaces");
var host_1 = require("./ts-host/host");
var FileInfo_1 = require("./TsParser/FileInfo");
describe('convertPrivateClassesToInterfaces', function () {
    var basePath = 'a/b/c';
    var moduleDoc = { id: 'someModule', basePath: basePath };
    var mockDeclaration = { getSourceFile: function () { return typescript_1.createSourceFile('x/y/z', 'blah blah', typescript_1.ScriptTarget.ES5); }, pos: 0, end: 0 };
    var classSymbol = {
        getDeclarations: function () { return [mockDeclaration]; },
        name: 'privateClass',
        valueDeclaration: mockDeclaration,
    };
    var classDoc;
    var docs;
    beforeEach(function () {
        spyOn(FileInfo_1.FileInfo.prototype, 'getRealFilePath').and.callFake(function (filePath) { return filePath; });
        classDoc = new ClassExportDoc_1.ClassExportDoc(new host_1.Host(), moduleDoc, classSymbol);
        classDoc.constructorDoc = { internal: true };
        docs = [classDoc];
    });
    it('should convert private class docs to interface docs', function () {
        convertPrivateClassesToInterfaces_1.convertPrivateClassesToInterfaces(docs, false);
        expect(docs[0].docType).toEqual('interface');
    });
    it('should not touch non-private class docs', function () {
        classDoc.constructorDoc = {};
        convertPrivateClassesToInterfaces_1.convertPrivateClassesToInterfaces(docs, false);
        expect(docs[0].docType).toEqual('class');
    });
    it('should convert the heritage since interfaces use `extends` not `implements`', function () {
        var heritage = new ClassLikeExportDoc_1.HeritageInfo({}, '');
        classDoc.implementsClauses = [heritage];
        convertPrivateClassesToInterfaces_1.convertPrivateClassesToInterfaces(docs, false);
        expect(docs[0].extendsClauses).toEqual([heritage]);
    });
    it('should add new injectable reference types, if specified, to the passed in collection', function () {
        convertPrivateClassesToInterfaces_1.convertPrivateClassesToInterfaces(docs, true);
        expect(docs[1]).toEqual(jasmine.objectContaining({
            docType: 'const',
            id: 'someModule/privateClass',
            name: 'privateClass',
            type: 'InjectableReference',
        }));
    });
});
//# sourceMappingURL=convertPrivateClassesToInterfaces.spec.js.map