"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs");
var typescript_1 = require("typescript");
var path = require('canonical-path');
// We need to provide our own version of CompilerHost because we want to set the
// base directory and specify what extensions to consider when trying to load a source
// file
var CustomCompilerHost = /** @class */ (function () {
    function CustomCompilerHost(options, baseDir, extensions, log) {
        this.options = options;
        this.baseDir = baseDir;
        this.extensions = extensions;
        this.log = log;
        this.writeFile = function () { };
    }
    CustomCompilerHost.prototype.getSourceFile = function (fileName, languageVersion, onError) {
        var text;
        var baseFilePath;
        var resolvedPath;
        var resolvedPathWithExt;
        // let's just try loading the file as-is initially
        try {
            resolvedPath = path.resolve(this.baseDir, fileName);
            text = fs.readFileSync(resolvedPath, { encoding: this.options.charset });
            this.log.debug('found source file:', fileName);
            return typescript_1.createSourceFile(path.relative(this.baseDir, resolvedPath), text, languageVersion);
        }
        catch (e) {
            // if it is a folder then try loading the index file of that folder
            if (e.code === 'EISDIR') {
                return this.getSourceFile(fileName + '/index.ts', languageVersion, onError);
            }
            // otherwise ignore the error and move on to the strategy below...
        }
        // Special case for `/// <reference types="x">` directives.
        // Typescript does not fully resolve these before calling getSourceFile
        // so fileName ends up looking like `node_modules/@types/x/index.d.ts`.
        // In the case that node_modules is below the baseDir, we look
        // for ../node_modules/@types/x/index.d.ts, ../..node_modules/@types/x/index.d.ts, etc...
        if (fileName.startsWith(path.join('node_modules', '@types')) && fileName.endsWith('index.d.ts')) {
            // The base directory path is already posix normalized through TypeScript. In order to
            // properly determine the depth of the base dir, the delimiter is always a forward slash.
            var baseDirDepth = this.baseDir.split('/').length;
            var maybe = path.join('..', fileName);
            for (var i = 0; i < baseDirDepth; ++i) {
                try {
                    resolvedPath = path.resolve(this.baseDir, maybe);
                    text = fs.readFileSync(resolvedPath, { encoding: this.options.charset });
                    this.log.debug('found source file:', fileName);
                    return typescript_1.createSourceFile(path.relative(this.baseDir, resolvedPath), text, languageVersion);
                }
                catch (e) {
                    // ignore the error and move on to the next maybe...
                }
                maybe = path.join('..', maybe);
            }
        }
        // Strip off the extension and resolve relative to the baseDir
        baseFilePath = fileName.replace(/\.[^.\/]+$/, '');
        resolvedPath = path.resolve(this.baseDir, baseFilePath);
        baseFilePath = path.relative(this.baseDir, resolvedPath);
        // Iterate through each possible extension and return the first source file that is actually found
        for (var _i = 0, _a = this.extensions; _i < _a.length; _i++) {
            var extension = _a[_i];
            // Try reading the content from files using each of the given extensions
            try {
                resolvedPathWithExt = resolvedPath + extension;
                this.log.silly('getSourceFile:', resolvedPathWithExt);
                text = fs.readFileSync(resolvedPathWithExt, { encoding: this.options.charset });
                this.log.debug('found source file:', fileName, resolvedPathWithExt);
                return typescript_1.createSourceFile(baseFilePath + extension, text, languageVersion);
            }
            catch (e) {
                // Try again if the file simply did not exist, otherwise report the error as a warning
                if (e.code !== 'ENOENT') {
                    if (onError)
                        onError(e.message);
                    this.log.warn('Error reading ' + resolvedPathWithExt + ' : ' + e.message);
                }
            }
        }
        throw new Error('No SourceFile found with path ' + fileName);
    };
    CustomCompilerHost.prototype.getDefaultLibFileName = function (options) {
        return path.resolve(path.dirname(typescript_1.sys.getExecutingFilePath()), typescript_1.getDefaultLibFileName(options));
    };
    CustomCompilerHost.prototype.getCurrentDirectory = function () {
        return this.baseDir;
    };
    CustomCompilerHost.prototype.getDirectories = function (p) {
        return [];
    };
    CustomCompilerHost.prototype.useCaseSensitiveFileNames = function () {
        return typescript_1.sys.useCaseSensitiveFileNames;
    };
    CustomCompilerHost.prototype.getCanonicalFileName = function (fileName) {
        // if underlying system can distinguish between two files whose names differs only in cases then file name already in canonical form.
        // otherwise use toLowerCase as a canonical form.
        return typescript_1.sys.useCaseSensitiveFileNames ? fileName : fileName.toLowerCase();
    };
    CustomCompilerHost.prototype.getNewLine = function () {
        return typescript_1.sys.newLine;
    };
    CustomCompilerHost.prototype.fileExists = function (fileName) {
        return fs.existsSync(fileName);
    };
    CustomCompilerHost.prototype.readFile = function (fileName) {
        /* tslint:disable:no-console */
        this.log.debug('readFile', fileName);
        return fs.readFileSync(fileName, 'utf-8');
    };
    return CustomCompilerHost;
}());
exports.CustomCompilerHost = CustomCompilerHost;
//# sourceMappingURL=CustomCompilerHost.js.map