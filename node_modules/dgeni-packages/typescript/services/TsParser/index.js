"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable:no-bitwise */
var typescript_1 = require("typescript");
var CustomCompilerHost_1 = require("./CustomCompilerHost");
// This import lacks type definitions.
var path = require('canonical-path');
var getExportDocType_1 = require("./getExportDocType");
exports.getExportDocType = getExportDocType_1.getExportDocType;
var getContent_1 = require("./getContent");
exports.getContent = getContent_1.getContent;
var getAccessibility_1 = require("./getAccessibility");
exports.getAccessibility = getAccessibility_1.getAccessibility;
var TsParser = /** @class */ (function () {
    function TsParser(log) {
        this.log = log;
        // These are the extension that we should consider when trying to load a module
        // During migration from Traceur, there is a mix of `.ts`, `.es6` and `.js` (atScript)
        // files in the project and the TypeScript compiler only looks for `.ts` files when trying
        // to load imports.
        this.extensions = ['.ts', '.js'];
        // The options for the TS compiler
        this.options = {
            allowNonTsExtensions: true,
            charset: 'utf8',
            newLine: typescript_1.NewLineKind.LineFeed,
        };
    }
    TsParser.prototype.parse = function (fileNames, baseDir) {
        var _this = this;
        // "Compile" a program from the given module filenames, to get hold of a
        // typeChecker that can be used to interrogate the modules, exports and so on.
        var host = new CustomCompilerHost_1.CustomCompilerHost(this.options, baseDir, this.extensions, this.log);
        var program = typescript_1.createProgram(fileNames, this.options, host);
        var typeChecker = program.getTypeChecker();
        // Create an array of module symbols for each file we were given
        var moduleSymbols = [];
        fileNames.forEach(function (fileName) {
            var sourceFile = program.getSourceFile(fileName);
            if (!sourceFile) {
                throw new Error('Invalid source file: ' + fileName);
            }
            else if (!sourceFile.symbol) {
                // Some files contain only a comment and no actual module code
                _this.log.warn('No module code found in ' + fileName);
            }
            else {
                moduleSymbols.push(sourceFile.symbol);
            }
        });
        moduleSymbols.forEach(function (tsModule) {
            // The type checker has a nice helper function that returns an array of Symbols representing the exports for a given module
            tsModule.exportArray = typeChecker.getExportsOfModule(tsModule);
            tsModule.exportArray.forEach(function (moduleExport) {
                // Although 'star' imports (e.g. `export * from 'some/module';) get resolved automatically by the compiler/binder,
                // it seems that explicit imports (e.g. `export {SomeClass} from 'some/module'`) do not so we have to do a little work.
                if (moduleExport.flags & typescript_1.SymbolFlags.Alias) {
                    // To maintain the alias information (particularly the alias name) we just attach the original "resolved" symbol to the alias symbol
                    moduleExport.resolvedSymbol = typeChecker.getAliasedSymbol(moduleExport);
                }
            });
        });
        moduleSymbols.typeChecker = typeChecker;
        return { host: host, moduleSymbols: moduleSymbols, program: program, typeChecker: typeChecker };
    };
    return TsParser;
}());
exports.TsParser = TsParser;
//# sourceMappingURL=index.js.map