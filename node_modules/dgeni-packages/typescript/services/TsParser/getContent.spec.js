"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require(".");
var getContent_1 = require("./getContent");
var path = require('canonical-path');
describe('getContent', function () {
    var parser;
    var basePath;
    beforeEach(function () {
        parser = new _1.TsParser(require('dgeni/lib/mocks/log')(false));
        basePath = path.resolve(__dirname, '../../mocks');
    });
    it('should get the leading jsdoc comments for exports', function () {
        var parseInfo = parser.parse(['tsParser/getContent.test.ts'], basePath);
        var module = parseInfo.moduleSymbols[0];
        expect(getContent_1.getContent(module.exportArray[0].getDeclarations()[0])).toEqual('Description of TestClass\n@deprecated warning');
        expect(getContent_1.getContent(module.exportArray[1].getDeclarations()[0])).toEqual('Description of function');
    });
    it('should get the leading jsdoc comments for class members and their parameters', function () {
        var parseInfo = parser.parse(['tsParser/getContent.test.ts'], basePath);
        var module = parseInfo.moduleSymbols[0];
        expect(getContent_1.getContent(module.exportArray[0].members.get('property').valueDeclaration)).toEqual('Some property');
        var method = module.exportArray[0].members.get('method').valueDeclaration;
        expect(getContent_1.getContent(method)).toEqual('Some method');
        expect(getContent_1.getContent(method.parameters[0])).toEqual('param 1');
    });
    it('should properly concatenate multiple leading comments', function () {
        var parseInfo = parser.parse(['tsParser/multipleLeadingComments.ts'], basePath);
        var module = parseInfo.moduleSymbols[0];
        expect(getContent_1.getContent(module.exportArray[0].getDeclarations()[0])).toEqual('Not a license comment.\nThis is a test function');
    });
    describe('leading comments concatenation disabled', function () {
        it('should be able to disable concatenation', function () {
            var parseInfo = parser.parse(['tsParser/multipleLeadingComments.ts'], basePath);
            var module = parseInfo.moduleSymbols[0];
            expect(getContent_1.getContent(module.exportArray[0].getDeclarations()[0], false))
                .toEqual('This is a test function');
        });
        it('should not throw if node does not have any leading comment', function () {
            var parseInfo = parser.parse(['tsParser/multipleLeadingComments.ts'], basePath);
            var module = parseInfo.moduleSymbols[0];
            expect(function () { return getContent_1.getContent(module.exportArray[1].getDeclarations()[0], false); })
                .not.toThrow();
        });
        it('should skip leading single-line comments', function () {
            var parseInfo = parser.parse(['tsParser/multipleLeadingComments.ts'], basePath);
            var module = parseInfo.moduleSymbols[0];
            expect(getContent_1.getContent(module.exportArray[2].getDeclarations()[0], false))
                .toEqual('This is the real comment.');
        });
        it('should skip leading non-js multi line comments', function () {
            var parseInfo = parser.parse(['tsParser/multipleLeadingComments.ts'], basePath);
            var module = parseInfo.moduleSymbols[0];
            expect(getContent_1.getContent(module.exportArray[3].getDeclarations()[0], false))
                .toEqual('First real comment.');
        });
    });
});
//# sourceMappingURL=getContent.spec.js.map