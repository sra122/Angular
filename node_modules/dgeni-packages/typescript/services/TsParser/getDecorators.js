"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var typescript_1 = require("typescript");
var LineFeedPrinter_1 = require("./LineFeedPrinter");
var nodeToString_1 = require("./nodeToString");
function getDecorators(declaration) {
    if (declaration.decorators) {
        return declaration.decorators.map(function (decorator) {
            var callExpression = getCallExpression(decorator);
            if (callExpression) {
                return {
                    argumentInfo: callExpression.arguments.map(function (argument) { return parseArgument(argument); }),
                    arguments: callExpression.arguments.map(function (argument) {
                        return LineFeedPrinter_1.lineFeedPrinter.printNode(typescript_1.EmitHint.Expression, argument, declaration.getSourceFile());
                    }),
                    expression: decorator,
                    isCallExpression: true,
                    name: nodeToString_1.nodeToString(callExpression.expression),
                };
            }
            else {
                return {
                    expression: decorator,
                    isCallExpression: false,
                    name: nodeToString_1.nodeToString(decorator.expression),
                };
            }
        });
    }
}
exports.getDecorators = getDecorators;
function getCallExpression(decorator) {
    if (decorator.expression.kind === typescript_1.SyntaxKind.CallExpression) {
        return decorator.expression;
    }
}
function parseProperties(properties) {
    var result = {};
    properties.forEach(function (property) {
        if (property.kind === typescript_1.SyntaxKind.PropertyAssignment) {
            result[nodeToString_1.nodeToString(property.name)] = parseArgument(property.initializer);
        }
    });
    return result;
}
function parseArgument(argument) {
    if (argument.kind === typescript_1.SyntaxKind.ObjectLiteralExpression) {
        return parseProperties(argument.properties);
    }
    if (argument.kind === typescript_1.SyntaxKind.ArrayLiteralExpression) {
        return argument.elements.map(function (element) { return nodeToString_1.nodeToString(element); });
    }
    return nodeToString_1.nodeToString(argument);
}
//# sourceMappingURL=getDecorators.js.map