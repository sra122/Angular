"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = require("@angular/core");
var forms_1 = require("@angular/forms");
var util_1 = require("util");
var terra_placement_enum_1 = require("../../../helpers/enums/terra-placement.enum");
var MAX_LASTLY_USED_ENTRIES = 5;
var TerraSuggestionBoxComponent = /** @class */ (function () {
    function TerraSuggestionBoxComponent(elementRef) {
        this.elementRef = elementRef;
        this.inputTooltipPlacement = terra_placement_enum_1.TerraPlacementEnum.TOP;
        this.inputListBoxValues = [];
        /**
         * @deprecated since it notifies the user at exactly the same time as ngModelChange <-> onChangeCallback
         */
        this.outputValueChanged = new core_1.EventEmitter();
        this.outputClicked = new core_1.EventEmitter();
        this.textInputValueChange = new core_1.EventEmitter();
        this.isValid = true;
        this.displayListBoxValues = [];
        this.lastSelectedValues = [];
        this.listBoxHeadingKey = '';
        this._selectedValue = null;
        this.tmpSelectedValue = null;
        this._textInputValue = '';
        this._toggleOpen = false;
        this.onTouchedCallback = function () { return undefined; };
        this.onChangeCallback = function (_) { return undefined; };
    }
    TerraSuggestionBoxComponent_1 = TerraSuggestionBoxComponent;
    TerraSuggestionBoxComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.clickListener = function (event) {
            _this.clickedOutside(event);
        };
        this.inputTooltipPlacement = terra_placement_enum_1.TerraPlacementEnum.TOP;
        this.tmpSelectedValue = null;
        this.isValid = true;
        this._toggleOpen = false;
        this.hasLabel = !util_1.isNull(this.inputName);
        this.lastSelectedValues = [];
        this.listBoxHeadingKey = '';
        this.noEntriesTextKey = this.inputWithRecentlyUsed ? 'terraSuggestionBox.noRecentlyUsed' : 'terraSuggestionBox.noSuggestions';
        if (!this.inputWithRecentlyUsed) {
            // initialize the displayed list with all possible values
            this.displayListBoxValues = this.inputListBoxValues;
        }
    };
    TerraSuggestionBoxComponent.prototype.ngOnChanges = function (changes) {
        var _this = this;
        if (changes['inputListBoxValues']) {
            this.displayListBoxValues = this.inputListBoxValues;
            if (changes['inputListBoxValues'].currentValue.length > 0 &&
                !util_1.isNullOrUndefined(this.selectedValue) &&
                !this.inputListBoxValues.find(function (x) { return _this.selectedValue.value === x.value; })) {
                // reset selected value if the value does not exists or the list is empty
                this.selectedValue = null;
            }
        }
    };
    TerraSuggestionBoxComponent.prototype.registerOnChange = function (fn) {
        this.onChangeCallback = fn;
    };
    TerraSuggestionBoxComponent.prototype.registerOnTouched = function (fn) {
        this.onTouchedCallback = fn;
    };
    TerraSuggestionBoxComponent.prototype.writeValue = function (value) {
        this.value = value;
    };
    Object.defineProperty(TerraSuggestionBoxComponent.prototype, "value", {
        get: function () {
            return !util_1.isNullOrUndefined(this.selectedValue) ? this.selectedValue.value : null;
        },
        set: function (value) {
            if (util_1.isNullOrUndefined(this.inputListBoxValues) || util_1.isNullOrUndefined(value)) {
                this.selectedValue = null;
            }
            else {
                this.selectedValue = this.inputListBoxValues.find(function (item) { return item.value === value; });
            }
            this.tmpSelectedValue = this.selectedValue;
        },
        enumerable: true,
        configurable: true
    });
    TerraSuggestionBoxComponent.prototype.onClick = function (evt) {
        evt.stopPropagation(); // prevents the click listener on the document to be fired right after
        this.toggleOpen = !this.toggleOpen;
    };
    Object.defineProperty(TerraSuggestionBoxComponent.prototype, "toggleOpen", {
        get: function () {
            return this._toggleOpen;
        },
        set: function (value) {
            if (this._toggleOpen !== value && value === true) {
                document.addEventListener('click', this.clickListener, true);
                this.focusSelectedElement();
            }
            else if (this._toggleOpen !== value && value === false) {
                document.removeEventListener('click', this.clickListener);
            }
            this._toggleOpen = value;
        },
        enumerable: true,
        configurable: true
    });
    TerraSuggestionBoxComponent.prototype.clickedOutside = function (event) {
        if (!this.elementRef.nativeElement.contains(event.target)) {
            this.toggleOpen = false;
        }
    };
    TerraSuggestionBoxComponent.prototype.select = function (value) {
        // check if value is available
        if (!this.displayListBoxValues.find(function (elem) { return elem === value; })) {
            return;
        }
        // update selected value
        this.selectedValue = value;
        // update last selected values
        if (this.inputWithRecentlyUsed) {
            this.updateLastSelectedValues();
        }
        // update temp selected value
        this.tmpSelectedValue = this.selectedValue;
    };
    TerraSuggestionBoxComponent.prototype.updateLastSelectedValues = function () {
        var _this = this;
        // check if newly selected value has been selected lastly
        var valueSelected = this.lastSelectedValues.find(function (value) {
            return value.caption === _this.selectedValue.caption &&
                value.value === _this.selectedValue.value;
        });
        // add value to the last selected values, if it is not already added
        if (util_1.isNullOrUndefined(valueSelected)) {
            var length_1 = this.lastSelectedValues.unshift({
                caption: this.selectedValue.caption,
                value: this.selectedValue.value
            });
            // check if length of the array exceeds the maximum amount of "lastly used" entries
            if (length_1 > MAX_LASTLY_USED_ENTRIES) {
                // remove last element of the array
                this.lastSelectedValues.pop();
            }
        }
    };
    TerraSuggestionBoxComponent.prototype.onChange = function () {
        var searchString = this.textInputValue;
        this.toggleOpen = true;
        if (!util_1.isNullOrUndefined(searchString) && searchString.length >= 3) {
            this.listBoxHeadingKey = 'terraSuggestionBox.suggestions';
            this.noEntriesTextKey = 'terraSuggestionBox.noSuggestions';
            if (!util_1.isNullOrUndefined(this.inputListBoxValues)) {
                this.displayListBoxValues = this.inputListBoxValues.filter(function (value) {
                    // check if search string has a full match
                    if (value.caption.toUpperCase().includes(searchString.toUpperCase())) {
                        return true;
                    }
                    // search for partial strings
                    var searchStringIncluded = true;
                    searchString.split(' ').forEach(function (word) {
                        searchStringIncluded = searchStringIncluded && value.caption.toUpperCase().includes(word.toUpperCase());
                    });
                    return searchStringIncluded;
                });
            }
        }
        else if (this.inputWithRecentlyUsed) {
            this.listBoxHeadingKey = 'terraSuggestionBox.recentlyUsed';
            this.noEntriesTextKey = 'terraSuggestionBox.noRecentlyUsed';
            this.displayListBoxValues = this.lastSelectedValues;
        }
        else if (!util_1.isNullOrUndefined(this.inputListBoxValues)) {
            this.displayListBoxValues = this.inputListBoxValues;
        }
        // update selected value
        this.setSelectedValue(this.displayListBoxValues.find(function (val) { return val.caption === searchString; }), true);
    };
    /**
     * @deprecated use ngModel instead to reset the selected value
     */
    TerraSuggestionBoxComponent.prototype.resetComponentValue = function () {
        this.value = null;
        this.selectedValue = null;
        this.tmpSelectedValue = null;
    };
    TerraSuggestionBoxComponent.prototype.onKeyDown = function (event) {
        var _this = this;
        // check if one of the dedicated keys has been pressed
        if (!(event.key === 'ArrowDown' || event.key === 'ArrowUp' || event.key === 'Enter' || event.key === 'Escape')) {
            return;
        }
        // check if there is any selected value yet
        if (util_1.isNullOrUndefined(this.tmpSelectedValue)) {
            this.tmpSelectedValue = this.displayListBoxValues[0];
        }
        else {
            // get the array index of the selected value
            var index = this.displayListBoxValues.findIndex(function (item) {
                return item.value === _this.tmpSelectedValue.value;
            });
            // check if element has been found
            if (index >= 0) {
                // determine the key, that has been pressed
                switch (event.key) {
                    case 'ArrowDown': // mark the succeeding list element
                        if (index + 1 < this.displayListBoxValues.length) {
                            // open dropdown if not already opened
                            if (!this.toggleOpen) {
                                this.toggleOpen = true;
                            }
                            // mark next element for selection
                            this.tmpSelectedValue = this.displayListBoxValues[index + 1];
                            // adjust scrolling viewport
                            this.focusSelectedElement();
                        }
                        break;
                    case 'ArrowUp': // mark the preceding list element
                        if (index - 1 >= 0) {
                            // open dropdown if not already opened
                            if (!this.toggleOpen) {
                                this.toggleOpen = true;
                            }
                            // mark previous element for selection
                            this.tmpSelectedValue = this.displayListBoxValues[index - 1];
                            // adjust scrolling viewport
                            this.focusSelectedElement();
                        }
                        break;
                    case 'Enter': // select the marked element
                        // check if element is really available
                        if (this.displayListBoxValues.find(function (item) { return item === _this.tmpSelectedValue; })) {
                            this.select(this.tmpSelectedValue); // select the chosen element
                            this.toggleOpen = false; // close the dropdown
                        }
                        break;
                    case 'Escape': // close the dropdown
                        this.toggleOpen = false; // close the dropdown
                        break;
                }
            }
            else {
                this.tmpSelectedValue = this.displayListBoxValues[0];
            }
        }
        // stop event bubbling
        event.stopPropagation();
    };
    TerraSuggestionBoxComponent.prototype.focusSelectedElement = function () {
        // get the temporary selected DOM element
        var selectedElementRef = this.renderedListBoxValues.find(function (value) {
            return value.nativeElement.classList.contains('selected');
        });
        // check if the element has been found
        if (selectedElementRef) {
            var spanElement = selectedElementRef.nativeElement;
            // scroll to the selected element
            spanElement.parentElement.scrollTop = spanElement.offsetTop - spanElement.parentElement.offsetTop;
        }
    };
    /**
     * workaround to prevent calling the select() method on the label click
     * @param event
     */
    TerraSuggestionBoxComponent.prototype.onInputClick = function (event) {
        this.outputClicked.emit(event);
        // check if the input has been clicked
        if (event.target.nodeName === 'INPUT') {
            // select the input text <-> mark all
            event.target.select();
        }
    };
    Object.defineProperty(TerraSuggestionBoxComponent.prototype, "textInputValue", {
        get: function () {
            return this._textInputValue;
        },
        set: function (value) {
            if (this._textInputValue !== value) {
                this.textInputValueChange.emit(value);
            }
            this._textInputValue = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TerraSuggestionBoxComponent.prototype, "selectedValue", {
        get: function () {
            return this._selectedValue;
        },
        set: function (value) {
            this.setSelectedValue(value);
        },
        enumerable: true,
        configurable: true
    });
    TerraSuggestionBoxComponent.prototype.setSelectedValue = function (value, onChange) {
        // does not do anything if the value changes from undefined to null or reverse
        if (util_1.isNullOrUndefined(this._selectedValue) && util_1.isNullOrUndefined(value)) {
            return;
        }
        // the value has changed?
        if (this._selectedValue !== value) {
            // update local model
            this._selectedValue = value;
            this.tmpSelectedValue = this._selectedValue;
            // execute callback functions
            this.onTouchedCallback(); // this may be called when the text input value changes instead!?
            this.onChangeCallback(this.value);
            this.outputValueChanged.emit(this._selectedValue);
            // finally update text input value
            if (!onChange) {
                this.textInputValue = !util_1.isNullOrUndefined(this._selectedValue) ? this._selectedValue.caption : '';
            }
        }
    };
    __decorate([
        core_1.Input(),
        __metadata("design:type", String)
    ], TerraSuggestionBoxComponent.prototype, "inputName", void 0);
    __decorate([
        core_1.Input(),
        __metadata("design:type", Boolean)
    ], TerraSuggestionBoxComponent.prototype, "inputIsRequired", void 0);
    __decorate([
        core_1.Input(),
        __metadata("design:type", Boolean)
    ], TerraSuggestionBoxComponent.prototype, "inputIsDisabled", void 0);
    __decorate([
        core_1.Input(),
        __metadata("design:type", String)
    ], TerraSuggestionBoxComponent.prototype, "inputTooltipText", void 0);
    __decorate([
        core_1.Input(),
        __metadata("design:type", String)
    ], TerraSuggestionBoxComponent.prototype, "inputTooltipPlacement", void 0);
    __decorate([
        core_1.Input(),
        __metadata("design:type", Array)
    ], TerraSuggestionBoxComponent.prototype, "inputListBoxValues", void 0);
    __decorate([
        core_1.Input(),
        __metadata("design:type", Boolean)
    ], TerraSuggestionBoxComponent.prototype, "inputWithRecentlyUsed", void 0);
    __decorate([
        core_1.Output(),
        __metadata("design:type", core_1.EventEmitter)
    ], TerraSuggestionBoxComponent.prototype, "outputValueChanged", void 0);
    __decorate([
        core_1.Output(),
        __metadata("design:type", core_1.EventEmitter)
    ], TerraSuggestionBoxComponent.prototype, "outputClicked", void 0);
    __decorate([
        core_1.Output(),
        __metadata("design:type", core_1.EventEmitter)
    ], TerraSuggestionBoxComponent.prototype, "textInputValueChange", void 0);
    __decorate([
        core_1.ViewChildren('renderedListBoxValues'),
        __metadata("design:type", core_1.QueryList)
    ], TerraSuggestionBoxComponent.prototype, "renderedListBoxValues", void 0);
    TerraSuggestionBoxComponent = TerraSuggestionBoxComponent_1 = __decorate([
        core_1.Component({
            selector: 'terra-suggestion-box',
            styles: [require('./terra-suggestion-box.component.scss')],
            template: require('./terra-suggestion-box.component.html'),
            providers: [
                {
                    provide: forms_1.NG_VALUE_ACCESSOR,
                    useExisting: core_1.forwardRef(function () { return TerraSuggestionBoxComponent_1; }),
                    multi: true
                }
            ]
        }),
        __metadata("design:paramtypes", [core_1.ElementRef])
    ], TerraSuggestionBoxComponent);
    return TerraSuggestionBoxComponent;
    var TerraSuggestionBoxComponent_1;
}());
exports.TerraSuggestionBoxComponent = TerraSuggestionBoxComponent;

//# sourceMappingURL=terra-suggestion-box.component.js.map
