"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("reflect-metadata");
var util_1 = require("util");
var _1 = require("../../../../../");
var TerraFormFieldHelper = /** @class */ (function () {
    function TerraFormFieldHelper() {
    }
    TerraFormFieldHelper.extractFormFields = function (formModel) {
        var formFields = Reflect.getMetadata(_1.TERRA_FORM_PROPERTY_METADATA_KEY, formModel.constructor);
        if (!util_1.isNullOrUndefined(formFields)) {
            Object.keys(formFields)
                .forEach(function (formFieldProperty) {
                var formField = formFields[formFieldProperty];
                if (util_1.isNullOrUndefined(formField.isList)) {
                    formField.isList = Reflect.getMetadata('design:type', formModel.constructor, formFieldProperty) === Array;
                }
                if (!util_1.isNullOrUndefined(formModel[formFieldProperty])
                    && Reflect.hasMetadata(_1.TERRA_FORM_PROPERTY_METADATA_KEY, formModel[formFieldProperty].constructor)) {
                    formField.children = TerraFormFieldHelper.extractFormFields(formModel[formFieldProperty]);
                }
            });
        }
        console.log(formFields);
        return formFields;
    };
    TerraFormFieldHelper.injectOption = function (formFields, type, optionKey, optionValue) {
        var _this = this;
        Object.keys(formFields).forEach(function (key) {
            if (formFields[key].type === type) {
                formFields[key].options = formFields[key].options || {};
                formFields[key].options[optionKey] = optionValue;
            }
            if (!util_1.isNullOrUndefined(formFields[key].children)) {
                formFields[key].children = _this.injectOption(formFields[key].children, type, optionKey, optionValue);
            }
        });
        return formFields;
    };
    TerraFormFieldHelper.isLegacyFormFields = function (formFields) {
        return util_1.isArray(formFields) || Object.keys(formFields).some(function (key) { return !util_1.isNullOrUndefined(formFields[key].label); });
    };
    TerraFormFieldHelper.detectLegacyFormFields = function (formFields) {
        var _this = this;
        if (util_1.isArray(formFields)) {
            var transformedFields_1 = {};
            formFields.forEach(function (field) {
                var transformedField = _this.transformLegacyFormField(field);
                transformedFields_1[transformedField.key] = transformedField.field;
            });
            return transformedFields_1;
        }
        else if (TerraFormFieldHelper.isLegacyFormFields(formFields)) {
            return this.detectLegacyFormFields(_1.TerraJsonToFormFieldService.generateFormFields(formFields));
        }
        return formFields;
    };
    TerraFormFieldHelper.transformLegacyFormField = function (field) {
        var result = {
            key: field.key,
            field: null
        };
        var type = this.CONTROL_TYPE_MAP[field.controlType];
        result.field = {
            type: type,
            options: {
                name: field.label,
                tooltip: field.tooltip,
                tooltipPlacement: field.tooltipPlacement,
                required: field.required
            }
        };
        var transformFn = 'transform' + type.charAt(0).toUpperCase() + type.substr(1) + 'Field';
        if (util_1.isFunction(this[transformFn])) {
            result.field = this[transformFn](result.field, field);
        }
        if (!!field.pattern) {
            result.field.isValid = field.pattern.toString();
        }
        else {
            var validators = [];
            if (field.minLength >= 0) {
                validators.push('this.length >= ' + field.minLength);
            }
            if (field.maxLength >= 0) {
                validators.push('this.length <= ' + field.maxLength);
            }
            if (!util_1.isNullOrUndefined(field.minValue)) {
                validators.push('this >= ' + field.minValue);
            }
            if (!util_1.isNullOrUndefined(field.maxValue)) {
                validators.push('this <= ' + field.maxValue);
            }
            result.field.isValid = validators.join(' && ');
        }
        if (field.controlType === _1.TerraControlTypeEnum.CONDITIONAL_CONTAINER
            || field.controlType === _1.TerraControlTypeEnum.HORIZONTAL_CONTAINER
            || field.controlType === _1.TerraControlTypeEnum.VERTICAL_CONTAINER) {
            result.field.children = this.detectLegacyFormFields(field.containerEntries);
        }
        return result;
    };
    TerraFormFieldHelper.transformCodeEditorField = function (result, field) {
        result.options.fixedHeight = field.fixedHeight;
        return result;
    };
    TerraFormFieldHelper.transformDoubleField = function (result, field) {
        result.options.isPrice = field.isPrice;
        result.options.decimalCount = field.decimalCount;
        return result;
    };
    TerraFormFieldHelper.transformFileField = function (result, field) {
        result.options.allowedExtensions = field.inputAllowedExtensions;
        return result;
    };
    TerraFormFieldHelper.transformCheckboxGroupField = function (result, field) {
        result.options.checkBoxValues = field.checkBoxValues;
        return result;
    };
    TerraFormFieldHelper.transformTextField = function (result, field) {
        result.options.isPassword = field.isPassword;
        result.options.isIBAN = field.isIBAN;
        result.options.isReadOnly = field.isReadOnly;
        return result;
    };
    TerraFormFieldHelper.transformSelectField = function (result, field) {
        result.options.listBoxValues = field.selectBoxValues;
        return result;
    };
    TerraFormFieldHelper.CONTROL_TYPE_MAP = {
        checkBox: 'checkbox',
        conditionalContainer: 'vertical',
        datePicker: 'date',
        horizontalContainer: 'horizontal',
        inputFile: 'file',
        inputText: 'text',
        inputTextArea: 'textarea',
        inputNumber: 'number',
        inputDouble: 'double',
        selectBox: 'select',
        verticalContainer: 'vertical',
        categoryPicker: 'category',
        multiCheckBox: 'checkboxGroup',
        noteEditor: 'noteEditor',
        codeEditor: 'codeEditor'
    };
    return TerraFormFieldHelper;
}());
exports.TerraFormFieldHelper = TerraFormFieldHelper;

//# sourceMappingURL=terra-form-field.helper.js.map
