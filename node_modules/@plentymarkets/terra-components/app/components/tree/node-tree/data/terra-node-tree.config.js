"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("util");
var angular_l10n_1 = require("angular-l10n");
var core_1 = require("@angular/core");
var TerraNodeTreeConfig = /** @class */ (function () {
    function TerraNodeTreeConfig(translation) {
        this.translation = translation;
        this._list = [];
    }
    /**
     * @description Adds a node.
     * @param nodeToAdd The provided node to add to the tree.
     * @param parent Optional. The provided parent where nodeToAdd should be added to.
     * @param openParents Optional. Open all parents.
     */
    TerraNodeTreeConfig.prototype.addNode = function (nodeToAdd, parent, openParents) {
        // check if the node to add is already added
        var alreadyAddedNode = this.findNodeById(nodeToAdd.id);
        if (util_1.isNullOrUndefined(alreadyAddedNode)) {
            this.setDefaultVisibility(nodeToAdd);
            // check children to set the parent correctly
            if (!util_1.isNullOrUndefined(nodeToAdd.children)) {
                this.recursiveSetParentAndDefaultVisibility(nodeToAdd.children, nodeToAdd);
            }
            // add to first level if no parent nor current selected node is given
            if (util_1.isNullOrUndefined(this.currentSelectedNode) && util_1.isNullOrUndefined(parent)) {
                this._list.push(nodeToAdd);
            }
            else {
                // set parent
                nodeToAdd.parent = !util_1.isNullOrUndefined(parent) ? parent : this.currentSelectedNode;
                // check children of parent to decide where to add the node
                if (util_1.isNullOrUndefined(nodeToAdd.parent.children)) {
                    nodeToAdd.parent.children = [nodeToAdd];
                }
                else {
                    nodeToAdd.parent.children.push(nodeToAdd);
                }
                if (!util_1.isNullOrUndefined(openParents) && openParents) {
                    this.toggleOpenParent(nodeToAdd, openParents);
                }
            }
        }
        else {
            console.error('Node ' + nodeToAdd.name + ' with id ' + nodeToAdd.id + ' already added!');
        }
    };
    TerraNodeTreeConfig.prototype.setDefaultVisibility = function (node) {
        if (node.isVisible) {
            node.defaultVisibility = true;
        }
        else {
            node.defaultVisibility = false;
        }
    };
    TerraNodeTreeConfig.prototype.getRecursiveNodePath = function (node, name) {
        if (!util_1.isNullOrUndefined(node)) {
            if (util_1.isNullOrUndefined(name)) {
                name = this.translation.translate(node.name);
            }
            else {
                name = this.translation.translate(node.name) + ' Â» ' + name;
            }
            if (!util_1.isNullOrUndefined(node.parent)) {
                return this.getRecursiveNodePath(node.parent, name);
            }
            else {
                return name;
            }
        }
        return name;
    };
    /**
     * @description Adds a node to a given parentId.
     * @param parentId The identifier of the parent node.
     * @param node The node to be added.
     * @param openParents Optional. Open all parents.
     */
    TerraNodeTreeConfig.prototype.addChildToNodeById = function (parentId, node, openParents) {
        var foundNode = this.recursiveFindNodeById(this.list, parentId);
        if (util_1.isNullOrUndefined(foundNode)) {
            console.error('Node with id ' + parentId + ' not found!');
        }
        else {
            this.addNode(node, foundNode, openParents);
        }
    };
    /**
     * @description Adds a list of nodes to a given parentId.
     * @param parentId The identifier of the parent node.
     * @param nodeList The node list to be added.
     * @param openParents Optional. Open all parents.
     */
    TerraNodeTreeConfig.prototype.addChildrenToNodeById = function (parentId, nodeList, openParents) {
        var _this = this;
        var foundNode = this.recursiveFindNodeById(this.list, parentId);
        if (util_1.isNullOrUndefined(foundNode)) {
            console.error('Node with id ' + parentId + ' not found!');
        }
        else {
            nodeList.forEach(function (node) {
                _this.addNode(node, foundNode, openParents);
            });
        }
    };
    /**
     * @description Removes a given node.
     * @param node The node to be removed.
     */
    TerraNodeTreeConfig.prototype.removeNode = function (node) {
        var foundNode = this.recursiveFindNode(this.list, node);
        if (util_1.isNullOrUndefined(foundNode)) {
            console.error('Node ' + node.name + ' with id ' + node.id + ' not found!');
        }
        else {
            this.internalRemoveNode(node);
        }
    };
    // removes a given node
    TerraNodeTreeConfig.prototype.internalRemoveNode = function (node) {
        var parent = node.parent;
        if (!util_1.isNullOrUndefined(parent)) {
            var index = parent.children.indexOf(node);
            parent.children.splice(index, 1);
        }
        if (node === this.currentSelectedNode) {
            this._currentSelectedNode = null;
        }
    };
    /**
     * @description Removes a node by ID.
     * @param id The ID of the node to be removed.
     */
    TerraNodeTreeConfig.prototype.removeNodeById = function (id) {
        var foundNode = this.recursiveFindNodeById(this.list, id);
        if (util_1.isNullOrUndefined(foundNode)) {
            console.error('Node with id ' + id + ' not found!');
        }
        else {
            this.internalRemoveNode(foundNode);
        }
    };
    /**
     * @description Updates a node by given ID.
     * @param id The ID of the node.
     * @param newNode The node with the new data.
     */
    TerraNodeTreeConfig.prototype.updateNodeById = function (id, newNode) {
        if (newNode.id.toString() !== id.toString()) {
            console.warn('ID ' + id + ' is different from new node ID!');
        }
        // search for node
        var foundNode = this.recursiveFindNodeById(this.list, id);
        if (util_1.isNullOrUndefined(foundNode)) {
            console.error('Node with id ' + id + ' not found!');
        }
        else {
            // just copy stuff
            foundNode.id = newNode.id;
            foundNode.name = newNode.name;
            foundNode.children = newNode.children;
            foundNode.icon = newNode.icon;
            foundNode.isActive = newNode.isActive;
            foundNode.isOpen = newNode.isOpen;
            foundNode.isVisible = newNode.isVisible;
            foundNode.defaultVisibility = newNode.defaultVisibility;
            foundNode.isLoading = newNode.isLoading;
            foundNode.tags = newNode.tags;
            foundNode.value = newNode.value;
            foundNode.parent = newNode.parent;
            foundNode.hasLoaded = newNode.hasLoaded;
            foundNode.onClick = newNode.onClick;
            foundNode.onLazyLoad = newNode.onLazyLoad;
        }
    };
    /**
     * @description Find an existing node by ID.
     * @param id The ID to find the correct node.
     */
    TerraNodeTreeConfig.prototype.findNodeById = function (id) {
        return this.recursiveFindNodeById(this.list, id);
    };
    /**
     * @description Find an existing node.
     * @param node The node to be found.
     */
    TerraNodeTreeConfig.prototype.findNode = function (node) {
        return this.recursiveFindNode(this.list, node);
    };
    // find node
    TerraNodeTreeConfig.prototype.recursiveFindNode = function (nodeList, nodeToFind) {
        var foundNode = null;
        for (var _i = 0, nodeList_1 = nodeList; _i < nodeList_1.length; _i++) {
            var node = nodeList_1[_i];
            if (node === nodeToFind) {
                foundNode = node;
                return foundNode;
            }
            else if (node.children) {
                foundNode = this.recursiveFindNode(node.children, nodeToFind);
                if (!util_1.isNull(foundNode)) {
                    break;
                }
            }
        }
        return foundNode;
    };
    // find node by id
    TerraNodeTreeConfig.prototype.recursiveFindNodeById = function (nodeList, id) {
        var foundNode = null;
        for (var _i = 0, nodeList_2 = nodeList; _i < nodeList_2.length; _i++) {
            var node = nodeList_2[_i];
            if (node.id.toString() === id.toString()) {
                foundNode = node;
                return foundNode;
            }
            else if (node.children) {
                foundNode = this.recursiveFindNodeById(node.children, id);
                if (!util_1.isNull(foundNode)) {
                    break;
                }
            }
        }
        return foundNode;
    };
    Object.defineProperty(TerraNodeTreeConfig.prototype, "list", {
        /**
         * @description The list with all the nodes.
         */
        get: function () {
            return this._list;
        },
        /**
         * @description Set a list with all the nodes.
         * @param value The node list to be shown.
         */
        set: function (value) {
            this.recursiveSetParentAndDefaultVisibility(value);
            this._list = value;
        },
        enumerable: true,
        configurable: true
    });
    // set parents to all nodes
    TerraNodeTreeConfig.prototype.recursiveSetParentAndDefaultVisibility = function (list, parent) {
        for (var _i = 0, list_1 = list; _i < list_1.length; _i++) {
            var node = list_1[_i];
            this.setDefaultVisibility(node);
            if (!util_1.isNullOrUndefined(parent)) {
                node.parent = parent;
            }
            if (!util_1.isNullOrUndefined(node.children)) {
                this.recursiveSetParentAndDefaultVisibility(node.children, node);
            }
        }
    };
    /**
     * @description Open all parents of given node.
     * @param node The node to open its parents.
     * @param isOpen Toggle open or not.
     */
    TerraNodeTreeConfig.prototype.toggleOpenParent = function (node, isOpen) {
        if (!util_1.isNullOrUndefined(node) && !util_1.isNullOrUndefined(node.parent)) {
            node.parent.isOpen = isOpen;
            this.toggleOpenParent(node.parent, isOpen);
        }
    };
    /**
     * @description Close all nodes.
     */
    TerraNodeTreeConfig.prototype.closeAllNodes = function () {
        this.toggleOpenChildren(this.list, false);
    };
    /**
     * @description Open all children of given node.
     * @param nodeList The node list to open its children.
     * @param isOpen Toggle open or not.
     */
    TerraNodeTreeConfig.prototype.toggleOpenChildren = function (nodeList, isOpen) {
        var _this = this;
        nodeList.forEach(function (node) {
            node.isOpen = isOpen;
            if (!util_1.isNullOrUndefined(node.children)) {
                _this.toggleOpenChildren(node.children, isOpen);
            }
        });
    };
    /**
     * @description Call the lazy loading function of given node.
     * @param node The node where lazy loading is defined.
     */
    TerraNodeTreeConfig.prototype.handleLazyLoading = function (node) {
        var _this = this;
        // check if lazy loading is desired
        if (!node.hasLoaded && !util_1.isNullOrUndefined(node.onLazyLoad)) {
            node.hasLoaded = true;
            node.isLoading = true;
            // subscribe to Observable
            node.onLazyLoad().subscribe(function () {
                node.hasLoaded = true;
                node.isLoading = false;
                node.isOpen = true;
                _this.checkVisibilityAndAssignDefault(node.children);
            }, function () {
                node.hasLoaded = false;
                node.isLoading = false;
            });
        }
        else {
            node.isOpen = !node.isOpen;
        }
    };
    Object.defineProperty(TerraNodeTreeConfig.prototype, "currentSelectedNode", {
        /**
         * @description Get the selected node.
         */
        get: function () {
            return this._currentSelectedNode;
        },
        /**
         * @description Set a node as selected.
         * @param node The node to be set as selected.
         */
        set: function (node) {
            if (!util_1.isNullOrUndefined(node)) {
                this.toggleOpenParent(node, true);
                this.recursiveSetNodeInactive(this.list);
                node.isActive = true;
                this._currentSelectedNode = node;
            }
            else {
                this._currentSelectedNode = null;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @description Reset the entire tree.
     */
    TerraNodeTreeConfig.prototype.reset = function () {
        this._list = [];
        this._currentSelectedNode = null;
    };
    /**
     * @description Set a node as selected by given ID.
     * @param id The ID to select a node.
     */
    TerraNodeTreeConfig.prototype.setCurrentSelectedNodeById = function (id) {
        var foundNode = this.recursiveFindNodeById(this.list, id);
        if (util_1.isNullOrUndefined(foundNode)) {
            console.error('Node with id ' + id + ' not found!');
        }
        else {
            this.currentSelectedNode = foundNode;
        }
    };
    // set all nodes inactive
    TerraNodeTreeConfig.prototype.recursiveSetNodeInactive = function (nodeList) {
        var _this = this;
        nodeList.forEach(function (node) {
            node.isActive = false;
            if (!util_1.isNullOrUndefined(node.children) && node.children.length > 0) {
                _this.recursiveSetNodeInactive(node.children);
            }
        });
    };
    /**
     * @description Toggle the visibility for all children.
     * @param nodeList The node list to toggle visibility of its children.
     * @param isVisible Toggle visibility.
     */
    TerraNodeTreeConfig.prototype.toggleVisiblityForAllChildren = function (nodeList, isVisible) {
        var _this = this;
        nodeList.forEach(function (node) {
            node.isVisible = isVisible;
            if (!util_1.isNullOrUndefined(node.children)) {
                _this.toggleVisiblityForAllChildren(node.children, isVisible);
            }
        });
    };
    /**
     * @description Toggle the visibility for all parents.
     * @param parentNode The node to toggle visibility of its parent.
     * @param isVisible Toggle visibility.
     */
    TerraNodeTreeConfig.prototype.toggleVisibilityForAllParents = function (parentNode, isVisible) {
        parentNode.isVisible = isVisible;
        if (!util_1.isNullOrUndefined(parentNode.parent)) {
            this.toggleVisibilityForAllParents(parentNode.parent, isVisible);
        }
    };
    TerraNodeTreeConfig.prototype.checkVisibilityAndAssignDefault = function (nodeList) {
        var _this = this;
        if (!util_1.isNullOrUndefined(nodeList)) {
            nodeList.forEach(function (node) {
                _this.setDefaultVisibility(node);
                if (!util_1.isNullOrUndefined(node.children)) {
                    _this.checkVisibilityAndAssignDefault(node.children);
                }
            });
        }
    };
    TerraNodeTreeConfig.prototype.checkDefaultAndAssignVisibility = function (nodeList) {
        var _this = this;
        nodeList.forEach(function (node) {
            if (node.defaultVisibility) {
                node.isVisible = true;
            }
            else {
                node.isVisible = false;
            }
            if (!util_1.isNullOrUndefined(node.children)) {
                _this.checkDefaultAndAssignVisibility(node.children);
            }
        });
    };
    TerraNodeTreeConfig = __decorate([
        core_1.Injectable(),
        __metadata("design:paramtypes", [angular_l10n_1.TranslationService])
    ], TerraNodeTreeConfig);
    return TerraNodeTreeConfig;
}());
exports.TerraNodeTreeConfig = TerraNodeTreeConfig;

//# sourceMappingURL=terra-node-tree.config.js.map
