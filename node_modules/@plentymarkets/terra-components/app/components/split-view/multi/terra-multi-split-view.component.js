"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = require("@angular/core");
var util_1 = require("util");
var terra_multi_split_view_config_1 = require("./injectables/terra-multi-split-view.config");
var router_1 = require("@angular/router");
var url_helper_1 = require("../../../helpers/url.helper");
var terra_multi_split_view_breadcrumbs_service_1 = require("./injectables/terra-multi-split-view-breadcrumbs.service");
var nextSplitViewId = 0;
var TerraMultiSplitViewComponent = /** @class */ (function () {
    function TerraMultiSplitViewComponent(zone, router, breadcrumbsService) {
        this.zone = zone;
        this.router = router;
        this.breadcrumbsService = breadcrumbsService;
        this.modules = [];
        this.isNullOrUndefined = util_1.isNullOrUndefined;
        this.inputShowBreadcrumbs = true; // default
        this.breadCrumbsPath = '';
        this.splitViewId = nextSplitViewId++;
        this._componentRoute = this.searchAngularRoutes(this.router.url);
    }
    TerraMultiSplitViewComponent.prototype.onWindowResize = function () {
        var _this = this;
        this.zone.runOutsideAngular(function () {
            // debounce resize, wait for resize to finish before updating the viewport
            if (_this.resizeTimeout) {
                clearTimeout(_this.resizeTimeout);
            }
            _this.resizeTimeout = setTimeout((function () {
                if (_this.inputConfig.currentSelectedView) {
                    _this.updateViewport(_this.inputConfig.currentSelectedView, true);
                }
            }).bind(_this), 500);
        });
    };
    TerraMultiSplitViewComponent.prototype.ngOnDestroy = function () {
        this.inputConfig.reset();
    };
    TerraMultiSplitViewComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.inputConfig.splitViewComponent = this;
        // catch routing events, but only those that select the tab where the split view is instantiated
        if (!util_1.isNullOrUndefined(this.router) && !util_1.isNullOrUndefined(this._componentRoute)) {
            // check if the given route exists in the route config
            if (this.routeExists(this._componentRoute)) {
                if (this.inputHasRouting) {
                    this.router.events.filter(function (event) {
                        return event instanceof router_1.NavigationEnd && event.url.startsWith(_this._componentRoute);
                    }).subscribe(function (event) {
                        if (_this.inputConfig.currentSelectedView && (_this._componentRoute + _this.inputConfig.currentSelectedView.url === event.url)) {
                            _this.updateViewport(_this.inputConfig.currentSelectedView, true);
                        }
                        else {
                            _this.inputConfig.navigateToViewByUrl(event.url);
                        }
                    });
                    this.inputConfig.navigateToViewByUrl(this.router.url);
                }
                else {
                    this.router.events.filter(function (event) {
                        return event instanceof router_1.NavigationStart && event.url === _this._componentRoute;
                    }).subscribe(function (path) {
                        _this.updateViewport(_this.inputConfig.currentSelectedView, true);
                    });
                }
            }
        }
    };
    Object.defineProperty(TerraMultiSplitViewComponent.prototype, "componentRoute", {
        get: function () {
            return this._componentRoute;
        },
        enumerable: true,
        configurable: true
    });
    TerraMultiSplitViewComponent.prototype.addToModulesIfNotExist = function (view) {
        // check whether view is null or undefined
        if (util_1.isNullOrUndefined(view)) {
            return;
        }
        // get hierarchy level of selected view
        var hierarchyLevel = this.getHierarchyLevelOfView(view);
        // check if modules array is not initialized
        if (util_1.isNullOrUndefined(this.modules[hierarchyLevel])) {
            this.modules.push({
                views: [],
                identifier: view.mainComponentName,
                width: view.focusedWidth ? view.focusedWidth : view.defaultWidth,
                currentSelectedView: view
            });
        }
        // get the module of the hierarchy
        var module = this.modules[hierarchyLevel];
        // initialize views array if null or undefined
        if (util_1.isNullOrUndefined(module.views)) {
            module.views = [];
        }
        // check if view is already added to module's views array
        if (!module.views.find(function (elem) { return elem === view; })) {
            // add view to the module's views array
            module.views.push(view);
        }
    };
    TerraMultiSplitViewComponent.prototype.setSelectedView = function (view) {
        // check whether view is defined
        if (util_1.isNullOrUndefined(view)) {
            return;
        }
        // check whether the view's module is defined
        var module = this.getModuleOfView(view);
        if (util_1.isNullOrUndefined(module)) {
            return;
        }
        // check if view is already selected
        if (this.inputConfig.currentSelectedView === view) {
            // stop execution, since the view is already selected
            return;
        }
        if (!util_1.isNullOrUndefined(this.inputConfig.selectBreadcrumbEventEmitter)) {
            this.inputConfig.selectBreadcrumbEventEmitter.next(view);
        }
        // check whether the view is already opened
        if (module.currentSelectedView === view) {
            // also set the width of the view
            module.width = !util_1.isNullOrUndefined(view.focusedWidth) ? view.focusedWidth : view.defaultWidth;
        }
        // vertical selection has changed
        else {
            // check if parent views are selected
            var parent_1 = view;
            while (!util_1.isNullOrUndefined(parent_1)) {
                var parentModule = this.getModuleOfView(parent_1);
                if (parentModule) {
                    if (!(parentModule.currentSelectedView === parent_1)) {
                        if (parent_1.parent) {
                            parentModule.views = parent_1.parent.children;
                        }
                        parentModule.currentSelectedView = parent_1;
                    }
                }
                parent_1 = parent_1.parent;
            }
            // rebuild modules for children views
            this.rebuildModules(view, module);
        }
        // if module has changed horizontally
        var inputModule = this.getModuleOfView(this.inputConfig.currentSelectedView);
        if (inputModule !== this.getModuleOfView(view)
            && !util_1.isNullOrUndefined(inputModule)) // this has to be checked, since a module can be removed and hence isn't existing anymore
         {
            inputModule.width = this.inputConfig.currentSelectedView.defaultWidth;
        }
        this.inputConfig.currentSelectedView = view;
        this.updateViewport(view);
        this.updateBreadCrumbs();
        this.updateBreadcrumbsList();
    };
    TerraMultiSplitViewComponent.prototype.updateBreadcrumbsList = function () {
        this.breadcrumbsService.breadcrumbList[this._componentRoute] =
            this.modules.map(function (module) {
                return module.currentSelectedView.name;
            });
    };
    TerraMultiSplitViewComponent.prototype.updateBreadCrumbs = function () {
        this.zone.runOutsideAngular(function () {
            // init breadcrumb sliding
            setTimeout(function () {
                $('.terra-breadcrumbs').each(function () {
                    $(this).find('li').each(function () {
                        var viewContainer = $(this).closest('.terra-breadcrumbs');
                        var viewContainerOffsetLeft = viewContainer.offset().left;
                        var viewContainerWidth = viewContainer.width();
                        $(this).off();
                        $(this).mouseenter(function () {
                            var elementWidth = $(this).width();
                            var elementOffsetLeft = $(this).offset().left;
                            var viewContainerScrollLeft = viewContainer.scrollLeft();
                            var offset = 0;
                            if (elementOffsetLeft < viewContainer.offset().left) {
                                offset = viewContainerScrollLeft + elementOffsetLeft - 10;
                            }
                            else if (elementOffsetLeft + elementWidth + 30 > viewContainerOffsetLeft + viewContainerWidth) {
                                offset = viewContainerScrollLeft + elementOffsetLeft + elementWidth + 30 - viewContainerWidth;
                            }
                            else {
                                return;
                            }
                            viewContainer.stop();
                            viewContainer.animate({ scrollLeft: offset }, 1200);
                        });
                    });
                });
            });
        });
    };
    TerraMultiSplitViewComponent.prototype.updateViewport = function (view, skipAnimation) {
        var _this = this;
        // check if view is defined
        if (util_1.isNullOrUndefined(view)) {
            return;
        }
        this.zone.runOutsideAngular(function () {
            var splitViewId = _this.splitViewId;
            setTimeout(function () {
                var id = view.mainComponentName;
                var parent = view.parent;
                var moduleIndex = 0;
                while (!util_1.isNullOrUndefined(parent)) {
                    parent = parent.parent;
                    moduleIndex++;
                }
                var anchor = $('#splitview' + splitViewId + '_module' + moduleIndex);
                var currentBreadcrumb = $('.' + id); // TODO: vwiebe, fix scope
                var breadCrumbContainer = currentBreadcrumb.closest('.terra-breadcrumbs');
                var viewContainer = anchor.parent();
                // focus breadcrumbs
                if (!util_1.isNullOrUndefined(currentBreadcrumb[0])) {
                    breadCrumbContainer.stop();
                    breadCrumbContainer.animate({ scrollLeft: (currentBreadcrumb[0].getBoundingClientRect().left + breadCrumbContainer.scrollLeft()) }, this.ANIMATION_SPEED);
                }
                // check if viewport needs to be adjusted
                if (!util_1.isNullOrUndefined(anchor[0]) &&
                    anchor[0].getBoundingClientRect().left > viewContainer.offset().left &&
                    anchor[0].getBoundingClientRect().right <= viewContainer.offset().left + viewContainer.outerWidth()) {
                    return;
                }
                // interrupt all ongoing animations to prevent queue
                viewContainer.stop();
                if (util_1.isNullOrUndefined(anchor[0])) {
                    return;
                }
                // focus view horizontally
                if (skipAnimation) {
                    viewContainer.scrollLeft(Math.ceil(anchor[0].getBoundingClientRect().left + viewContainer.scrollLeft() - viewContainer.offset().left));
                }
                else {
                    viewContainer.animate({ scrollLeft: (Math.ceil(anchor[0].getBoundingClientRect().left + viewContainer.scrollLeft() - viewContainer.offset().left)) }, this.ANIMATION_SPEED);
                }
            });
        });
    };
    TerraMultiSplitViewComponent.prototype.rebuildModules = function (view, module) {
        var _this = this;
        if (util_1.isNullOrUndefined(view)) {
            return;
        }
        var hierarchyLevel = this.getHierarchyLevelOfView(view);
        // cut off last elements if existing
        if (this.modules.length > hierarchyLevel) {
            this.modules = this.modules.slice(0, hierarchyLevel + 1);
        }
        // rebuild
        if (!util_1.isNullOrUndefined(view.children)) {
            view.children.forEach(function (child) {
                // add view to the modules array
                _this.addToModulesIfNotExist(child);
                // set selected view and rebuild sub tree for children
                _this.setSelectedView(child);
            });
        }
        // update the corresponding module's current- and lastSelectedView
        var moduleView = module.views.find(function (v) { return v === view; });
        // an existing view has been SELECTED?
        if (moduleView) {
            module.lastSelectedView = module.currentSelectedView;
            module.currentSelectedView = view;
            // also set the width of the view
            module.width = !util_1.isNullOrUndefined(view.focusedWidth) ? view.focusedWidth : view.defaultWidth;
        }
    };
    TerraMultiSplitViewComponent.prototype.removeFromModules = function (view) {
        var _this = this;
        // check whether view is null or undefined
        if (util_1.isNullOrUndefined(view)) {
            // ERROR... stop further execution
            return view;
        }
        // get the corresponding module
        var module = this.getModuleOfView(view);
        // check whether module is defined
        if (util_1.isNullOrUndefined(module)) {
            // ERROR... stop further execution
            return view;
        }
        // delete all children only if the view is selected and the children are rendered
        if (view === module.currentSelectedView) {
            if (!util_1.isNullOrUndefined(view.children)) {
                view.children.forEach(function (elem) {
                    _this.removeFromModules(elem);
                });
            }
        }
        // check if module has more than one view
        if (module.views.length <= 1) {
            // get the index of the module in the modules array
            var moduleIndex = this.modules.findIndex(function (mod) { return mod === module; });
            // check if the module has been found
            if (moduleIndex >= 0 && moduleIndex < this.modules.length) {
                // remove the whole module
                this.modules.splice(moduleIndex, 1);
                // select the views parent view
                return view.parent;
            }
        }
        else {
            // get the index of the view in the module's views array
            var viewIndex = module.views.findIndex(function (elem) { return elem === view; });
            // check if the view has been found
            if (viewIndex >= 0 && viewIndex < module.views.length) {
                // remove view from module's views array
                module.views.splice(viewIndex, 1);
            }
            // return the view that should be selected after deletion
            if (module.currentSelectedView === view && this.inputConfig.currentSelectedView === view) {
                return this.getLastSelectedOfModule(module);
            }
            else {
                // check if vertical selection has to be changed
                if (module.currentSelectedView === view) {
                    // rebuild modules array depending on the selected view
                    this.rebuildModules(this.getLastSelectedOfModule(module), module);
                }
                // do not change anything -> select the currently selected view
                return this.inputConfig.currentSelectedView;
            }
        }
    };
    TerraMultiSplitViewComponent.prototype.getModuleOfView = function (view) {
        // get hierarchy level of deleted view
        var hierarchyLevel = this.getHierarchyLevelOfView(view);
        return this.modules[hierarchyLevel];
    };
    TerraMultiSplitViewComponent.prototype.getHierarchyLevelOfView = function (view) {
        var hierarchyLevel = 0;
        var parent = view.parent;
        while (!util_1.isNullOrUndefined(parent)) {
            parent = parent.parent;
            hierarchyLevel++;
        }
        return hierarchyLevel;
    };
    TerraMultiSplitViewComponent.prototype.resizeViewAndModule = function (view) {
        var module = this.getModuleOfView(view);
        module.width = view.defaultWidth;
    };
    TerraMultiSplitViewComponent.prototype.removeView = function (view, event) {
        // stop event bubbling
        event.stopPropagation();
        // remove the selected view
        this.inputConfig.removeView(view);
    };
    TerraMultiSplitViewComponent.prototype.routeExists = function (route) {
        var noLeadingSlash = url_helper_1.UrlHelper.removeLeadingSlash(route);
        var routeParts = noLeadingSlash.split('/');
        var routeLevel = 0;
        // get the routing config
        var registeredRoutes = this.router.config;
        // scan the routing config
        while (routeLevel < routeParts.length) {
            if (util_1.isNullOrUndefined(registeredRoutes)) {
                return false;
            }
            // search the array for the route partial
            var foundRoute = registeredRoutes.find(function (registeredRoute) { return registeredRoute.path === routeParts[routeLevel]; });
            if (foundRoute) // the route partial is defined?
             {
                // into deep
                routeLevel++;
                registeredRoutes = foundRoute.children;
            }
            else {
                return false;
            }
        }
        // if the while loop ends, the route exists
        return true;
    };
    TerraMultiSplitViewComponent.prototype.getLastSelectedOfModule = function (module) {
        if (module.lastSelectedView && module.views.find(function (v) { return v === module.lastSelectedView; })) {
            return module.lastSelectedView;
        }
        // select the first view in the views array
        return module.views[0];
    };
    TerraMultiSplitViewComponent.prototype.handleBreadCrumbClick = function (view, event) {
        // prevent event bubbling
        if (event) {
            event.stopPropagation();
        }
        this.setSelectedView(view);
    };
    // TODO: The same functionality as TerraRouterHelper.getRouteBaseUrl()
    TerraMultiSplitViewComponent.prototype.searchAngularRoutes = function (url) {
        var urlWithoutLeadingSlash = url_helper_1.UrlHelper.removeLeadingSlash(url);
        var urlParts = urlWithoutLeadingSlash.split('/');
        var urlPart = urlParts.shift();
        var routes = this.router.config;
        var route = this.findRouteByPath(urlPart, routes);
        var baseUrl = '';
        while (!util_1.isNullOrUndefined(route) && urlParts.length > 0) {
            baseUrl += '/' + route.path;
            routes = route.children;
            urlPart = urlParts.shift();
            route = this.findRouteByPath(urlPart, routes);
        }
        if (util_1.isNullOrUndefined(route) && !util_1.isNullOrUndefined(routes) && !util_1.isNullOrUndefined(routes[0]) && routes[0].path === '**') {
            return baseUrl;
        }
        if (urlParts.length === 0 && !util_1.isNullOrUndefined(route)) {
            return baseUrl + '/' + route.path;
        }
        return undefined;
    };
    TerraMultiSplitViewComponent.prototype.findRouteByPath = function (routePath, routeConfig) {
        if (util_1.isNullOrUndefined(routeConfig)) {
            return undefined;
        }
        return routeConfig.find(function (route) {
            return route.path === routePath;
        });
    };
    TerraMultiSplitViewComponent.ANIMATION_SPEED = 1000; // ms
    __decorate([
        core_1.Input(),
        __metadata("design:type", terra_multi_split_view_config_1.TerraMultiSplitViewConfig)
    ], TerraMultiSplitViewComponent.prototype, "inputConfig", void 0);
    __decorate([
        core_1.Input(),
        __metadata("design:type", Boolean)
    ], TerraMultiSplitViewComponent.prototype, "inputShowBreadcrumbs", void 0);
    __decorate([
        core_1.Input(),
        __metadata("design:type", String)
    ], TerraMultiSplitViewComponent.prototype, "inputComponentRoute", void 0);
    __decorate([
        core_1.Input(),
        __metadata("design:type", Boolean)
    ], TerraMultiSplitViewComponent.prototype, "inputHasRouting", void 0);
    __decorate([
        core_1.HostListener('window:resize'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], TerraMultiSplitViewComponent.prototype, "onWindowResize", null);
    TerraMultiSplitViewComponent = __decorate([
        core_1.Component({
            selector: 'terra-multi-split-view',
            template: require('./terra-multi-split-view.component.html'),
            styles: [
                require('./terra-multi-split-view.component.scss'),
                require('./terra-multi-split-view.component.glob.scss').toString()
            ],
        }),
        __metadata("design:paramtypes", [core_1.NgZone, router_1.Router, terra_multi_split_view_breadcrumbs_service_1.TerraMultiSplitViewBreadcrumbsService])
    ], TerraMultiSplitViewComponent);
    return TerraMultiSplitViewComponent;
}());
exports.TerraMultiSplitViewComponent = TerraMultiSplitViewComponent;

//# sourceMappingURL=terra-multi-split-view.component.js.map
